# Gmsh - Copyright (C) 1997-2018 C. Geuzaine, J.-F. Remacle
#
# See the LICENSE.txt file for license information. Please report all
# bugs and problems to the public mailing list <gmsh@onelab.info>.

# This file defines the Gmsh Pyhton API.
#
# Do not edit it directly: it is automatically generated by `api/gen.py'.
#
# By design, the Gmsh Pyhton API is purely functional, and only uses elementary
# types (as well as `numpy' arrays if `numpy' is avaiable). A C++ as well as a
# pure C API are also automatically generated by `api/gen.py': see `gmsh.h'
# and `gmshc.h'.
#
# See `demos/api' for examples on how to use the Gmsh API. In particular,
# `demos/api' contains C++ and Python versions of several of the `.geo'
# tutorials from `tutorials'.

from ctypes import *
import signal
import os
import platform
from math import pi

signal.signal(signal.SIGINT, signal.SIG_DFL)
libdir = os.path.dirname(os.path.realpath(__file__))
if platform.system() == 'Windows':
    lib = CDLL(libdir + "/gmsh-3.0.dll")
elif platform.system() == 'Darwin':
    lib = CDLL(libdir + "/libgmsh.dylib")
else:
    lib = CDLL(libdir + "/libgmsh.so")

use_numpy = False
try:
    import numpy
    try:
        from weakref import finalize as weakreffinalize
    except:
        from backports.weakref import finalize as weakreffinalize
    use_numpy = True
except:
    pass

def _ostring(s):
    sp = s.value.decode("utf-8")
    lib.gmshFree(s)
    return sp

def _ovectorpair(ptr, size):
    if use_numpy:
        v = numpy.ctypeslib.as_array(ptr, (size//2, 2))
        weakreffinalize(v, lib.gmshFree, ptr)
    else:
        v = list((ptr[i * 2], ptr[i * 2 + 1]) for i in range(size//2))
        lib.gmshFree(ptr)
    return v

def _ovectorint(ptr, size):
    if use_numpy:
        v = numpy.ctypeslib.as_array(ptr, (size, ))
        weakreffinalize(v, lib.gmshFree, ptr)
    else:
        v = list(ptr[i] for i in range(size))
        lib.gmshFree(ptr)
    return v

def _ovectordouble(ptr, size):
    if use_numpy:
        v = numpy.ctypeslib.as_array(ptr, (size, ))
        weakreffinalize(v, lib.gmshFree, ptr)
    else:
        v = list(ptr[i] for i in range(size))
        lib.gmshFree(ptr)
    return v

def _ovectorstring(ptr, size):
    v = list(_ostring(cast(ptr[i], c_char_p)) for i in range(size))
    lib.gmshFree(ptr)
    return v

def _ovectorvectorint(ptr, size, n):
    v = [_ovectorint(pointer(ptr[i].contents), size[i]) for i in range(n.value)]
    lib.gmshFree(size)
    lib.gmshFree(ptr)
    return v

def _ovectorvectordouble(ptr, size, n):
    v = [_ovectordouble(pointer(ptr[i].contents), size[i]) for i in range(n.value)]
    lib.gmshFree(size)
    lib.gmshFree(ptr)
    return v

def _ovectorvectorpair(ptr, size, n):
    v = [_ovectorpair(pointer(ptr[i].contents), size[i]) for i in range(n.value)]
    lib.gmshFree(size)
    lib.gmshFree(ptr)
    return v

def _ivectorint(o):
    if use_numpy:
        return numpy.ascontiguousarray(o, numpy.int32).ctypes, c_size_t(len(o))
    else:
        return (c_int * len(o))(*o), c_size_t(len(o))

def _ivectorvectorint(os):
    n = len(os)
    parrays = [_ivectorint(o) for o in os]
    sizes = (c_size_t * n)(*(a[1] for a in parrays))
    arrays = (POINTER(c_int) * n)(*(cast(a[0], POINTER(c_int)) for a in parrays))
    arrays.ref = [a[0] for a in parrays]
    size = c_size_t(n)
    return arrays, sizes, size

def _ivectorvectordouble(os):
    n = len(os)
    parrays = [_ivectordouble(o) for o in os]
    sizes = (c_size_t * n)(*(a[1] for a in parrays))
    arrays = (POINTER(c_double) * n)(*(cast(a[0], POINTER(c_double)) for a in parrays))
    arrays.ref = [a[0] for a in parrays]
    size = c_size_t(n)
    return arrays, sizes, size

def _ivectordouble(o):
    if use_numpy:
        array = numpy.ascontiguousarray(o, numpy.float64)
        ct = array.ctypes
        ct.array = array
        return  ct, c_size_t(len(o))
    else:
        return (c_double * len(o))(*o), c_size_t(len(o))

def _ivectorpair(o):
    if use_numpy:
        array = numpy.ascontiguousarray(o, numpy.int32)
        ct = array.ctypes
        ct.array = array
        return  ct, c_size_t(len(o) * 2)
    else:
        return ((c_int * 2) * len(o))(*o), c_size_t(len(o) * 2)

def _iargcargv(o):
    return c_int(len(o)), (c_char_p * len(o))(*(s.encode() for s in o))


def initialize(argv=[], readConfigFiles=True):
    """
    Initializes Gmsh. This must be called before any call to the other
    functions in the API. If `argc' and `argv' are provided, they will be
    handled in the same way as the command line arguments in the Gmsh app. If
    `readConfigFiles' is set, reads system Gmsh configuration files (gmshrc and
    gmsh-options).
    """
    api_argc_, api_argv_ = _iargcargv(argv)
    ierr = c_int()
    lib.gmshInitialize(
        api_argc_, api_argv_,
        c_int(bool(readConfigFiles)),
        byref(ierr))
    if ierr.value != 0:
        raise ValueError(
            "gmshInitialize returned non-zero error code: ",
            ierr.value)

def finalize():
    """
    Finalizes Gmsh. This must be called when you are done using the Gmsh API.
    """
    ierr = c_int()
    lib.gmshFinalize(
        byref(ierr))
    if ierr.value != 0:
        raise ValueError(
            "gmshFinalize returned non-zero error code: ",
            ierr.value)

def open(fileName):
    """
    Opens a file. Equivalent to the `File->Open' menu in the Gmsh app. Handling
    of the file depends on its extension and/or its contents.
    """
    ierr = c_int()
    lib.gmshOpen(
        c_char_p(fileName.encode()),
        byref(ierr))
    if ierr.value != 0:
        raise ValueError(
            "gmshOpen returned non-zero error code: ",
            ierr.value)

def merge(fileName):
    """
    Merges a file. Equivalent to the `File->Merge' menu in the Gmsh app.
    Handling of the file depends on its extension and/or its contents.
    """
    ierr = c_int()
    lib.gmshMerge(
        c_char_p(fileName.encode()),
        byref(ierr))
    if ierr.value != 0:
        raise ValueError(
            "gmshMerge returned non-zero error code: ",
            ierr.value)

def write(fileName):
    """
    Writes a file. The export format is determined by the file extension.
    """
    ierr = c_int()
    lib.gmshWrite(
        c_char_p(fileName.encode()),
        byref(ierr))
    if ierr.value != 0:
        raise ValueError(
            "gmshWrite returned non-zero error code: ",
            ierr.value)

def clear():
    """
    Clears all loaded models and post-processing data, and adds a new empty
    model.
    """
    ierr = c_int()
    lib.gmshClear(
        byref(ierr))
    if ierr.value != 0:
        raise ValueError(
            "gmshClear returned non-zero error code: ",
            ierr.value)


class option:
    """
    Global option handling functions
    """

    @staticmethod
    def setNumber(name, value):
        """
        Sets a numerical option to `value'. `name' is of the form "category.option"
        or "category[num].option". Available categories and options are listed in
        the Gmsh reference manual.
        """
        ierr = c_int()
        lib.gmshOptionSetNumber(
            c_char_p(name.encode()),
            c_double(value),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshOptionSetNumber returned non-zero error code: ",
                ierr.value)

    @staticmethod
    def getNumber(name):
        """
        Gets the `value' of a numerical option.

        Returns `value'.
        """
        api_value_ = c_double()
        ierr = c_int()
        lib.gmshOptionGetNumber(
            c_char_p(name.encode()),
            byref(api_value_),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshOptionGetNumber returned non-zero error code: ",
                ierr.value)
        return api_value_.value

    @staticmethod
    def setString(name, value):
        """
        Sets a string option to `value'.
        """
        ierr = c_int()
        lib.gmshOptionSetString(
            c_char_p(name.encode()),
            c_char_p(value.encode()),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshOptionSetString returned non-zero error code: ",
                ierr.value)

    @staticmethod
    def getString(name):
        """
        Gets the `value' of a string option.

        Returns `value'.
        """
        api_value_ = c_char_p()
        ierr = c_int()
        lib.gmshOptionGetString(
            c_char_p(name.encode()),
            byref(api_value_),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshOptionGetString returned non-zero error code: ",
                ierr.value)
        return _ostring(api_value_)


class model:
    """
    Per-model functions
    """

    @staticmethod
    def add(name):
        """
        Adds a new model, with name `name', and sets it as the current model.
        """
        ierr = c_int()
        lib.gmshModelAdd(
            c_char_p(name.encode()),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshModelAdd returned non-zero error code: ",
                ierr.value)

    @staticmethod
    def remove():
        """
        Removes the current model.
        """
        ierr = c_int()
        lib.gmshModelRemove(
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshModelRemove returned non-zero error code: ",
                ierr.value)

    @staticmethod
    def list():
        """
        Lists the names of all models.

        Returns `names'.
        """
        api_names_, api_names_n_ = POINTER(POINTER(c_char))(), c_size_t()
        ierr = c_int()
        lib.gmshModelList(
            byref(api_names_), byref(api_names_n_),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshModelList returned non-zero error code: ",
                ierr.value)
        return _ovectorstring(api_names_, api_names_n_.value)

    @staticmethod
    def setCurrent(name):
        """
        Sets the current model to the model with name `name'. If several models
        have the same name, selects the one that was added first.
        """
        ierr = c_int()
        lib.gmshModelSetCurrent(
            c_char_p(name.encode()),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshModelSetCurrent returned non-zero error code: ",
                ierr.value)

    @staticmethod
    def getEntities(dim=-1):
        """
        Gets all the (elementary) geometrical entities in the current model. If
        `dim' is >= 0, returns only the entities of the specified dimension (e.g.
        points if `dim' == 0). The entities are returned as a vector of (dim, tag)
        integer pairs.

        Returns `dimTags'.
        """
        api_dimTags_, api_dimTags_n_ = POINTER(c_int)(), c_size_t()
        ierr = c_int()
        lib.gmshModelGetEntities(
            byref(api_dimTags_), byref(api_dimTags_n_),
            c_int(dim),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshModelGetEntities returned non-zero error code: ",
                ierr.value)
        return _ovectorpair(api_dimTags_, api_dimTags_n_.value)

    @staticmethod
    def getPhysicalGroups(dim=-1):
        """
        Gets all the physical groups in the current model. If `dim' is >= 0,
        returns only the entities of the specified dimension (e.g. physical points
        if `dim' == 0). The entities are returned as a vector of (dim, tag) integer
        pairs.

        Returns `dimTags'.
        """
        api_dimTags_, api_dimTags_n_ = POINTER(c_int)(), c_size_t()
        ierr = c_int()
        lib.gmshModelGetPhysicalGroups(
            byref(api_dimTags_), byref(api_dimTags_n_),
            c_int(dim),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshModelGetPhysicalGroups returned non-zero error code: ",
                ierr.value)
        return _ovectorpair(api_dimTags_, api_dimTags_n_.value)

    @staticmethod
    def getEntitiesForPhysicalGroup(dim, tag):
        """
        Gets the tags of all the (elementary) geometrical entities making up the
        physical group of dimension `dim' and tag `tag'.

        Returns `tags'.
        """
        api_tags_, api_tags_n_ = POINTER(c_int)(), c_size_t()
        ierr = c_int()
        lib.gmshModelGetEntitiesForPhysicalGroup(
            c_int(dim),
            c_int(tag),
            byref(api_tags_), byref(api_tags_n_),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshModelGetEntitiesForPhysicalGroup returned non-zero error code: ",
                ierr.value)
        return _ovectorint(api_tags_, api_tags_n_.value)

    @staticmethod
    def addPhysicalGroup(dim, tags, tag=-1):
        """
        Adds a physical group of dimension `dim', grouping the elementary entities
        with tags `tags'. The function returns the tag of the physical group, equal
        to `tag' if `tag' is positive, or a new tag if `tag' < 0.

        Returns an integer.
        """
        api_tags_, api_tags_n_ = _ivectorint(tags)
        ierr = c_int()
        api__result__ = lib.gmshModelAddPhysicalGroup(
            c_int(dim),
            api_tags_, api_tags_n_,
            c_int(tag),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshModelAddPhysicalGroup returned non-zero error code: ",
                ierr.value)
        return api__result__

    @staticmethod
    def setPhysicalName(dim, tag, name):
        """
        Sets the name of the physical group of dimension `dim' and tag `tag'.
        """
        ierr = c_int()
        lib.gmshModelSetPhysicalName(
            c_int(dim),
            c_int(tag),
            c_char_p(name.encode()),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshModelSetPhysicalName returned non-zero error code: ",
                ierr.value)

    @staticmethod
    def getPhysicalName(dim, tag):
        """
        Gets the name of the physical group of dimension `dim' and tag `tag'.

        Returns `name'.
        """
        api_name_ = c_char_p()
        ierr = c_int()
        lib.gmshModelGetPhysicalName(
            c_int(dim),
            c_int(tag),
            byref(api_name_),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshModelGetPhysicalName returned non-zero error code: ",
                ierr.value)
        return _ostring(api_name_)

    @staticmethod
    def getBoundary(dimTags, combined=True, oriented=True, recursive=False):
        """
        Gets the boundary of the geometrical entities `dimTags'. Returns in
        `outDimTags' the boundary of the individual entities (if `combined' is
        false) or the boundary of the combined geometrical shape formed by all
        input entities (if `combined' is true). Returns tags multiplied by the sign
        of the boundary entity if `oriented' is true. Applies the boundary operator
        recursively down to dimension 0 (i.e. to points) if `recursive' is true.

        Returns `outDimTags'.
        """
        api_dimTags_, api_dimTags_n_ = _ivectorpair(dimTags)
        api_outDimTags_, api_outDimTags_n_ = POINTER(c_int)(), c_size_t()
        ierr = c_int()
        lib.gmshModelGetBoundary(
            api_dimTags_, api_dimTags_n_,
            byref(api_outDimTags_), byref(api_outDimTags_n_),
            c_int(bool(combined)),
            c_int(bool(oriented)),
            c_int(bool(recursive)),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshModelGetBoundary returned non-zero error code: ",
                ierr.value)
        return _ovectorpair(api_outDimTags_, api_outDimTags_n_.value)

    @staticmethod
    def getEntitiesInBoundingBox(xmin, ymin, zmin, xmax, ymax, zmax, dim=-1):
        """
        Gets the (elementary) geometrical entities in the bounding box defined by
        the two points (`xmin', `ymin', `zmin') and (`xmax', `ymax', `zmax'). If
        `dim' is >= 0, returns only the entities of the specified dimension (e.g.
        points if `dim' == 0).

        Returns `tags'.
        """
        api_tags_, api_tags_n_ = POINTER(c_int)(), c_size_t()
        ierr = c_int()
        lib.gmshModelGetEntitiesInBoundingBox(
            c_double(xmin),
            c_double(ymin),
            c_double(zmin),
            c_double(xmax),
            c_double(ymax),
            c_double(zmax),
            byref(api_tags_), byref(api_tags_n_),
            c_int(dim),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshModelGetEntitiesInBoundingBox returned non-zero error code: ",
                ierr.value)
        return _ovectorpair(api_tags_, api_tags_n_.value)

    @staticmethod
    def getBoundingBox(dim, tag):
        """
        Gets the bounding box (`xmin', `ymin', `zmin'), (`xmax', `ymax', `zmax') of
        the geometrical entity of dimension `dim' and tag `tag'.

        Returns `xmin', `ymin', `zmin', `xmax', `ymax', `zmax'.
        """
        api_xmin_ = c_double()
        api_ymin_ = c_double()
        api_zmin_ = c_double()
        api_xmax_ = c_double()
        api_ymax_ = c_double()
        api_zmax_ = c_double()
        ierr = c_int()
        lib.gmshModelGetBoundingBox(
            c_int(dim),
            c_int(tag),
            byref(api_xmin_),
            byref(api_ymin_),
            byref(api_zmin_),
            byref(api_xmax_),
            byref(api_ymax_),
            byref(api_zmax_),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshModelGetBoundingBox returned non-zero error code: ",
                ierr.value)
        return (
            api_xmin_.value,
            api_ymin_.value,
            api_zmin_.value,
            api_xmax_.value,
            api_ymax_.value,
            api_zmax_.value)

    @staticmethod
    def addDiscreteEntity(dim, tag=-1, boundary=[]):
        """
        Adds a discrete geometrical entity (defined by a mesh) of dimension `dim'
        in the current model. The function returns the tag of the new discrete
        entity, equal to `tag' if `tag' is positive, or a new tag if `tag' < 0.
        `boundary' specifies the tags of the entities on the boundary of the
        discrete entity, if any. Specyfing `boundary' allows Gmsh to construct the
        topology of the overall model.

        Returns an integer.
        """
        api_boundary_, api_boundary_n_ = _ivectorint(boundary)
        ierr = c_int()
        api__result__ = lib.gmshModelAddDiscreteEntity(
            c_int(dim),
            c_int(tag),
            api_boundary_, api_boundary_n_,
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshModelAddDiscreteEntity returned non-zero error code: ",
                ierr.value)
        return api__result__

    @staticmethod
    def removeEntities(dimTags, recursive=False):
        """
        Removes the entities `dimTags' of the current model. If `recursive' is
        true, removes all the entities on their boundaries, down to dimension 0.
        """
        api_dimTags_, api_dimTags_n_ = _ivectorpair(dimTags)
        ierr = c_int()
        lib.gmshModelRemoveEntities(
            api_dimTags_, api_dimTags_n_,
            c_int(bool(recursive)),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshModelRemoveEntities returned non-zero error code: ",
                ierr.value)

    @staticmethod
    def getType(dim, tag):
        """
        Gets the type of the entity of dimension `dim' and tag `tag'.

        Returns `type'.
        """
        api_type_ = c_char_p()
        ierr = c_int()
        lib.gmshModelGetType(
            c_int(dim),
            c_int(tag),
            byref(api_type_),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshModelGetType returned non-zero error code: ",
                ierr.value)
        return _ostring(api_type_)


    class mesh:
        """
        Per-model meshing functions
        """

        @staticmethod
        def generate(dim):
            """
            Generates a mesh of the current model, up to dimension `dim' (0, 1, 2 or
            3).
            """
            ierr = c_int()
            lib.gmshModelMeshGenerate(
                c_int(dim),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshGenerate returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def partition(numPart):
            """
            Partitions the mesh of the current model into `numPart' partitions.
            """
            ierr = c_int()
            lib.gmshModelMeshPartition(
                c_int(numPart),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshPartition returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def refine():
            """
            Refines the mesh of the current model by uniformly splitting the elements.
            """
            ierr = c_int()
            lib.gmshModelMeshRefine(
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshRefine returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def setOrder(order):
            """
            Sets the order of the elements in the mesh of the current model to `order'.
            """
            ierr = c_int()
            lib.gmshModelMeshSetOrder(
                c_int(order),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshSetOrder returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def removeDuplicateNodes():
            """
            Removes duplicate mesh nodes in the mesh of the current model.
            """
            ierr = c_int()
            lib.gmshModelMeshRemoveDuplicateNodes(
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshRemoveDuplicateNodes returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def getLastEntityError():
            """
            Gets the last entities (if any) where a meshing error occurred. Currently
            only populated by the new 3D meshing algorithms.

            Returns `dimTags'.
            """
            api_dimTags_, api_dimTags_n_ = POINTER(c_int)(), c_size_t()
            ierr = c_int()
            lib.gmshModelMeshGetLastEntityError(
                byref(api_dimTags_), byref(api_dimTags_n_),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshGetLastEntityError returned non-zero error code: ",
                    ierr.value)
            return _ovectorpair(api_dimTags_, api_dimTags_n_.value)

        @staticmethod
        def getLastNodeError():
            """
            Gets the last mesh nodes (if any) where a meshing error occurred. Currently
            only populated by the new 3D meshing algorithms.

            Returns `nodeTags'.
            """
            api_nodeTags_, api_nodeTags_n_ = POINTER(c_int)(), c_size_t()
            ierr = c_int()
            lib.gmshModelMeshGetLastNodeError(
                byref(api_nodeTags_), byref(api_nodeTags_n_),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshGetLastNodeError returned non-zero error code: ",
                    ierr.value)
            return _ovectorint(api_nodeTags_, api_nodeTags_n_.value)

        @staticmethod
        def getNodes(dim=-1, tag=-1):
            """
            Gets the mesh nodes of the entity of dimension `dim' and `tag' tag. If
            `tag' < 0, gets the nodes for all entities of dimension `dim'. If `dim' and
            `tag' are negative, gets all the nodes in the mesh. `nodeTags' contains the
            node tags (their unique, strictly positive identification numbers). `coord'
            is a vector of length 3 times the length of `nodeTags' that contains the
            (x, y, z) coordinates of the nodes, concatenated. If `dim' >= 0,
            `parametricCoord' contains the parametric coordinates of the nodes, if
            available. The length of `parametricCoord' can be 0 or `dim' times the
            length of `nodeTags'.

            Returns `nodeTags', `coord', `parametricCoord'.
            """
            api_nodeTags_, api_nodeTags_n_ = POINTER(c_int)(), c_size_t()
            api_coord_, api_coord_n_ = POINTER(c_double)(), c_size_t()
            api_parametricCoord_, api_parametricCoord_n_ = POINTER(c_double)(), c_size_t()
            ierr = c_int()
            lib.gmshModelMeshGetNodes(
                byref(api_nodeTags_), byref(api_nodeTags_n_),
                byref(api_coord_), byref(api_coord_n_),
                byref(api_parametricCoord_), byref(api_parametricCoord_n_),
                c_int(dim),
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshGetNodes returned non-zero error code: ",
                    ierr.value)
            return (
                _ovectorint(api_nodeTags_, api_nodeTags_n_.value),
                _ovectordouble(api_coord_, api_coord_n_.value),
                _ovectordouble(api_parametricCoord_, api_parametricCoord_n_.value))

        @staticmethod
        def getElements(dim=-1, tag=-1):
            """
            Gets the mesh elements of the entity of dimension `dim' and `tag' tag. If
            `tag' < 0, gets the elements for all entities of dimension `dim'. If `dim'
            and `tag' are negative, gets all the elements in the mesh. `elementTypes'
            contains the MSH types of the elements (e.g. `2' for 3-node triangles: see
            `getElementProperties' to obtain the properties for a given element type).
            `elementTags' is a vector of the same length as `elementTypes'; each entry
            is a vector containing the tags (unique, strictly positive identifiers) of
            the elements of the corresponding type. `nodeTags' is also a vector of the
            same length as `elementTypes'; each entry is a vector of length equal to
            the number of elements of the given type times the number of nodes for this
            type of element, that contains the node tags of all the elements of the
            given type, concatenated.

            Returns `elementTypes', `elementTags', `nodeTags'.
            """
            api_elementTypes_, api_elementTypes_n_ = POINTER(c_int)(), c_size_t()
            api_elementTags_, api_elementTags_n_, api_elementTags_nn_ = POINTER(POINTER(c_int))(), POINTER(c_size_t)(), c_size_t()
            api_nodeTags_, api_nodeTags_n_, api_nodeTags_nn_ = POINTER(POINTER(c_int))(), POINTER(c_size_t)(), c_size_t()
            ierr = c_int()
            lib.gmshModelMeshGetElements(
                byref(api_elementTypes_), byref(api_elementTypes_n_),
                byref(api_elementTags_), byref(api_elementTags_n_), byref(api_elementTags_nn_),
                byref(api_nodeTags_), byref(api_nodeTags_n_), byref(api_nodeTags_nn_),
                c_int(dim),
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshGetElements returned non-zero error code: ",
                    ierr.value)
            return (
                _ovectorint(api_elementTypes_, api_elementTypes_n_.value),
                _ovectorvectorint(api_elementTags_, api_elementTags_n_, api_elementTags_nn_),
                _ovectorvectorint(api_nodeTags_, api_nodeTags_n_, api_nodeTags_nn_))

        @staticmethod
        def getElementProperties(elementType):
            """
            Gets the properties of an element of type `elementType': its name
            (`elementName'), dimension (`dim'), order (`order'), number of nodes
            (`numNodes') and parametric coordinates of nodes (`parametricCoord' vector,
            of length `dim' times `numNodes').

            Returns `elementName', `dim', `order', `numNodes', `parametricCoord'.
            """
            api_elementName_ = c_char_p()
            api_dim_ = c_int()
            api_order_ = c_int()
            api_numNodes_ = c_int()
            api_parametricCoord_, api_parametricCoord_n_ = POINTER(c_double)(), c_size_t()
            ierr = c_int()
            lib.gmshModelMeshGetElementProperties(
                c_int(elementType),
                byref(api_elementName_),
                byref(api_dim_),
                byref(api_order_),
                byref(api_numNodes_),
                byref(api_parametricCoord_), byref(api_parametricCoord_n_),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshGetElementProperties returned non-zero error code: ",
                    ierr.value)
            return (
                _ostring(api_elementName_),
                api_dim_.value,
                api_order_.value,
                api_numNodes_.value,
                _ovectordouble(api_parametricCoord_, api_parametricCoord_n_.value))

        @staticmethod
        def getIntegrationData(integrationType, functionSpaceType, dim=-1, tag=-1):
            """
            Gets the integration data for mesh elements of the entity of dimension
            `dim' and `tag' tag. The data is returned by element type and by element,
            in the same order as the data returned by `getElements'. `integrationType'
            specifies the type of integration (e.g. "Gauss4") and `functionSpaceType'
            specifies the function space (e.g. "IsoParametric"). `integrationPoints'
            contains for each element type a vector (of length 4 times the number of
            integration points) containing the parametric coordinates (u, v, w) and the
            weight associated to the integration points. `integrationData' contains for
            each element type a vector (of size 13 times the number of integration
            points) containing the (x, y, z) coordinates of the integration point, the
            determinant of the Jacobian and the 9 entries (by row) of the 3x3 Jacobian
            matrix. If `functionSpaceType' is provided, `functionSpaceNumComponents'
            returns the number of components returned by the evaluation of a basis
            function in the space and `functionSpaceData' contains for each element
            type the evaluation of the basis functions at the integration points.

            Returns `integrationPoints', `integrationData', `functionSpaceNumComponents', `functionSpaceData'.
            """
            api_integrationPoints_, api_integrationPoints_n_, api_integrationPoints_nn_ = POINTER(POINTER(c_double))(), POINTER(c_size_t)(), c_size_t()
            api_integrationData_, api_integrationData_n_, api_integrationData_nn_ = POINTER(POINTER(c_double))(), POINTER(c_size_t)(), c_size_t()
            api_functionSpaceNumComponents_ = c_int()
            api_functionSpaceData_, api_functionSpaceData_n_, api_functionSpaceData_nn_ = POINTER(POINTER(c_double))(), POINTER(c_size_t)(), c_size_t()
            ierr = c_int()
            lib.gmshModelMeshGetIntegrationData(
                c_char_p(integrationType.encode()),
                c_char_p(functionSpaceType.encode()),
                byref(api_integrationPoints_), byref(api_integrationPoints_n_), byref(api_integrationPoints_nn_),
                byref(api_integrationData_), byref(api_integrationData_n_), byref(api_integrationData_nn_),
                byref(api_functionSpaceNumComponents_),
                byref(api_functionSpaceData_), byref(api_functionSpaceData_n_), byref(api_functionSpaceData_nn_),
                c_int(dim),
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshGetIntegrationData returned non-zero error code: ",
                    ierr.value)
            return (
                _ovectorvectordouble(api_integrationPoints_, api_integrationPoints_n_, api_integrationPoints_nn_),
                _ovectorvectordouble(api_integrationData_, api_integrationData_n_, api_integrationData_nn_),
                api_functionSpaceNumComponents_.value,
                _ovectorvectordouble(api_functionSpaceData_, api_functionSpaceData_n_, api_functionSpaceData_nn_))

        @staticmethod
        def getElementTypes(dim=-1, tag=-1):
            """
            Gets the types of mesh elements in the entity of dimension `dim' and `tag'
            tag. If `tag' < 0, gets the types for all entities of dimension `dim'. If
            `dim' and `tag' are negative, gets all the types in the mesh.

            Returns `elementTypes'.
            """
            api_elementTypes_, api_elementTypes_n_ = POINTER(c_int)(), c_size_t()
            ierr = c_int()
            lib.gmshModelMeshGetElementTypes(
                byref(api_elementTypes_), byref(api_elementTypes_n_),
                c_int(dim),
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshGetElementTypes returned non-zero error code: ",
                    ierr.value)
            return _ovectorint(api_elementTypes_, api_elementTypes_n_.value)

        @staticmethod
        def getElementsByType(elementType, dim=-1, tag=-1):
            """
            Gets the mesh elements in the same way as `getElements', but for a single
            `elementType'.

            Returns `elementTags', `nodeTags'.
            """
            api_elementTags_, api_elementTags_n_ = POINTER(c_int)(), c_size_t()
            api_nodeTags_, api_nodeTags_n_ = POINTER(c_int)(), c_size_t()
            ierr = c_int()
            lib.gmshModelMeshGetElementsByType(
                c_int(elementType),
                byref(api_elementTags_), byref(api_elementTags_n_),
                byref(api_nodeTags_), byref(api_nodeTags_n_),
                c_int(dim),
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshGetElementsByType returned non-zero error code: ",
                    ierr.value)
            return (
                _ovectorint(api_elementTags_, api_elementTags_n_.value),
                _ovectorint(api_nodeTags_, api_nodeTags_n_.value))

        @staticmethod
        def getIntegrationDataByType(elementType, integrationType, functionSpaceType, dim=-1, tag=-1):
            """
            Gets the integration data for mesh elements in the same way as
            `getIntegrationData', but for a single `elementType'.

            Returns `integrationPoints', `integrationData', `functionSpaceNumComponents', `functionSpaceData'.
            """
            api_integrationPoints_, api_integrationPoints_n_ = POINTER(c_double)(), c_size_t()
            api_integrationData_, api_integrationData_n_ = POINTER(c_double)(), c_size_t()
            api_functionSpaceNumComponents_ = c_int()
            api_functionSpaceData_, api_functionSpaceData_n_ = POINTER(c_double)(), c_size_t()
            ierr = c_int()
            lib.gmshModelMeshGetIntegrationDataByType(
                c_int(elementType),
                c_char_p(integrationType.encode()),
                c_char_p(functionSpaceType.encode()),
                byref(api_integrationPoints_), byref(api_integrationPoints_n_),
                byref(api_integrationData_), byref(api_integrationData_n_),
                byref(api_functionSpaceNumComponents_),
                byref(api_functionSpaceData_), byref(api_functionSpaceData_n_),
                c_int(dim),
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshGetIntegrationDataByType returned non-zero error code: ",
                    ierr.value)
            return (
                _ovectordouble(api_integrationPoints_, api_integrationPoints_n_.value),
                _ovectordouble(api_integrationData_, api_integrationData_n_.value),
                api_functionSpaceNumComponents_.value,
                _ovectordouble(api_functionSpaceData_, api_functionSpaceData_n_.value))

        @staticmethod
        def setNodes(dim, tag, nodeTags, coord, parametricCoord=[]):
            """
            Sets the mesh nodes in the geometrical entity of dimension `dim' and tag
            `tag'. `nodetags' contains the node tags (their unique, strictly positive
            identification numbers). `coord' is a vector of length 3 times the length
            of `nodeTags' that contains the (x, y, z) coordinates of the nodes,
            concatenated. The optional `parametricCoord' vector contains the parametric
            coordinates of the nodes, if any. The length of `parametricCoord' can be 0
            or `dim' times the length of `nodeTags'.
            """
            api_nodeTags_, api_nodeTags_n_ = _ivectorint(nodeTags)
            api_coord_, api_coord_n_ = _ivectordouble(coord)
            api_parametricCoord_, api_parametricCoord_n_ = _ivectordouble(parametricCoord)
            ierr = c_int()
            lib.gmshModelMeshSetNodes(
                c_int(dim),
                c_int(tag),
                api_nodeTags_, api_nodeTags_n_,
                api_coord_, api_coord_n_,
                api_parametricCoord_, api_parametricCoord_n_,
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshSetNodes returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def setElements(dim, tag, types, elementTags, nodeTags):
            """
            Sets the mesh elements of the entity of dimension `dim' and `tag' tag.
            `types' contains the MSH types of the elements (e.g. `2' for 3-node
            triangles: see the Gmsh reference manual). `elementTags' is a vector of the
            same length as `types'; each entry is a vector containing the tags (unique,
            strictly positive identifiers) of the elements of the corresponding type.
            `nodeTags' is also a vector of the same length as `types'; each entry is a
            vector of length equal to the number of elements of the give type times the
            number of nodes per element, that contains the node tags of all the
            elements of the given type, concatenated.
            """
            api_types_, api_types_n_ = _ivectorint(types)
            api_elementTags_, api_elementTags_n_, api_elementTags_nn_ = _ivectorvectorint(elementTags)
            api_nodeTags_, api_nodeTags_n_, api_nodeTags_nn_ = _ivectorvectorint(nodeTags)
            ierr = c_int()
            lib.gmshModelMeshSetElements(
                c_int(dim),
                c_int(tag),
                api_types_, api_types_n_,
                api_elementTags_, api_elementTags_n_, api_elementTags_nn_,
                api_nodeTags_, api_nodeTags_n_, api_nodeTags_nn_,
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshSetElements returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def reclassifyNodes():
            """
            Redistributes all mesh nodes on their associated geometrical entity, based
            on the mesh elements. Can be used when importing mesh nodes in bulk (e.g.
            by associating them all to a single volume), to reclassify them correctly
            on model surfaces, curves, etc.
            """
            ierr = c_int()
            lib.gmshModelMeshReclassifyNodes(
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshReclassifyNodes returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def getNode(nodeTag):
            """
            Gets the coordinates and the parametric coordinates (if any) of the mesh
            node with tag `tag'. This is a useful by inefficient way of accessing mesh
            node data, as it relies on a cache stored in the model. For large meshes
            all the nodes in the model should be numbered in a continuous sequence of
            tags from 1 to N to maintain reasonnable performance (in this case the
            internal cache is based on a vector; otherwise it uses a map).

            Returns `coord', `parametricCoord'.
            """
            api_coord_, api_coord_n_ = POINTER(c_double)(), c_size_t()
            api_parametricCoord_, api_parametricCoord_n_ = POINTER(c_double)(), c_size_t()
            ierr = c_int()
            lib.gmshModelMeshGetNode(
                c_int(nodeTag),
                byref(api_coord_), byref(api_coord_n_),
                byref(api_parametricCoord_), byref(api_parametricCoord_n_),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshGetNode returned non-zero error code: ",
                    ierr.value)
            return (
                _ovectordouble(api_coord_, api_coord_n_.value),
                _ovectordouble(api_parametricCoord_, api_parametricCoord_n_.value))

        @staticmethod
        def getElement(elementTag):
            """
            Gets the type and node tags of the mesh element with tag `tag'. This is a
            useful but inefficient way of accessing mesh element data, as it relies on
            a cache stored in the model. For large meshes all the elements in the model
            should be numbered in a continuous sequence of tags from 1 to N to maintain
            reasonnable performance (in this case the internal cache is based on a
            vector; otherwise it uses a map).

            Returns `type', `nodeTags'.
            """
            api_type_ = c_int()
            api_nodeTags_, api_nodeTags_n_ = POINTER(c_int)(), c_size_t()
            ierr = c_int()
            lib.gmshModelMeshGetElement(
                c_int(elementTag),
                byref(api_type_),
                byref(api_nodeTags_), byref(api_nodeTags_n_),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshGetElement returned non-zero error code: ",
                    ierr.value)
            return (
                api_type_.value,
                _ovectorint(api_nodeTags_, api_nodeTags_n_.value))

        @staticmethod
        def setSize(dimTags, size):
            """
            Sets a mesh size constraint on the geometrical entities `dimTags'.
            Currently only entities of dimension 0 (points) are handled.
            """
            api_dimTags_, api_dimTags_n_ = _ivectorpair(dimTags)
            ierr = c_int()
            lib.gmshModelMeshSetSize(
                api_dimTags_, api_dimTags_n_,
                c_double(size),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshSetSize returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def setTransfiniteCurve(tag, numNodes, type="Progression", coef=1.):
            """
            Sets a transfinite meshing constraint on the curve `tag', with `numNodes'
            mesh nodes distributed according to `type' and `coef'. Currently supported
            types are "Progression" (geometrical progression with power `coef') and
            "Bump" (refinement toward both extremities of the curve).
            """
            ierr = c_int()
            lib.gmshModelMeshSetTransfiniteCurve(
                c_int(tag),
                c_int(numNodes),
                c_char_p(type.encode()),
                c_double(coef),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshSetTransfiniteCurve returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def setTransfiniteSurface(tag, arrangement="Left", cornerTags=[]):
            """
            Sets a transfinite meshing constraint on the surface `tag'. `arrangement'
            describes the arrangement of the triangles when the surface is not flagged
            as recombined: currently supported values are "Left", "Right",
            "AlternateLeft" and "AlternateRight". `cornerTags' can be used to specify
            the (3 or 4) corners of the transfinite interpolation explicitly;
            specifying the corners explicitly is mandatory if the surface has more that
            3 or 4 points on its boundary.
            """
            api_cornerTags_, api_cornerTags_n_ = _ivectorint(cornerTags)
            ierr = c_int()
            lib.gmshModelMeshSetTransfiniteSurface(
                c_int(tag),
                c_char_p(arrangement.encode()),
                api_cornerTags_, api_cornerTags_n_,
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshSetTransfiniteSurface returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def setTransfiniteVolume(tag, cornerTags=[]):
            """
            Sets a transfinite meshing constraint on the surface `tag'. `cornerTags'
            can be used to specify the (6 or 8) corners of the transfinite
            interpolation explicitly.
            """
            api_cornerTags_, api_cornerTags_n_ = _ivectorint(cornerTags)
            ierr = c_int()
            lib.gmshModelMeshSetTransfiniteVolume(
                c_int(tag),
                api_cornerTags_, api_cornerTags_n_,
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshSetTransfiniteVolume returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def setRecombine(dim, tag):
            """
            Sets a recombination meshing constraint on the geometrical entity of
            dimension `dim' and tag `tag'. Currently only entities of dimension 2 (to
            recombine triangles into quadrangles) are supported.
            """
            ierr = c_int()
            lib.gmshModelMeshSetRecombine(
                c_int(dim),
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshSetRecombine returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def setSmoothing(dim, tag, val):
            """
            Sets a smoothing meshing constraint on the geometrical entity of dimension
            `dim' and tag `tag'. `val' iterations of a Laplace smoother are applied.
            """
            ierr = c_int()
            lib.gmshModelMeshSetSmoothing(
                c_int(dim),
                c_int(tag),
                c_int(val),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshSetSmoothing returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def setReverse(dim, tag, val=True):
            """
            Sets a reverse meshing constraint on the geometrical entity of dimension
            `dim' and tag `tag'. If `val' is true, the mesh orientation will be
            reversed with respect to the natural mesh orientation (i.e. the orientation
            consistent with the orientation of the geometrical entity). If `val' is
            false, the mesh is left as-is.
            """
            ierr = c_int()
            lib.gmshModelMeshSetReverse(
                c_int(dim),
                c_int(tag),
                c_int(bool(val)),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshSetReverse returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def embed(dim, tags, inDim, inTag):
            """
            Embeds the geometrical entities of dimension `dim' and tags `tags' in the
            (inDim, inTag) geometrical entity. `inDim' must be strictly greater than
            `dim'.
            """
            api_tags_, api_tags_n_ = _ivectorint(tags)
            ierr = c_int()
            lib.gmshModelMeshEmbed(
                c_int(dim),
                api_tags_, api_tags_n_,
                c_int(inDim),
                c_int(inTag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshEmbed returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def setPeriodic(dim, tags, tagsSource, affineTransformation):
            """
            Sets the meshes of the entities of dimension `dim' and tag `tags' as
            periodic copies of the meshes of entities `tagsSource', using the affine
            transformation specified in `affineTransformation' (16 entries of a 4x4
            matrix, by row). Currently only available for `dim' == 1 and `dim' == 2.
            """
            api_tags_, api_tags_n_ = _ivectorint(tags)
            api_tagsSource_, api_tagsSource_n_ = _ivectorint(tagsSource)
            api_affineTransformation_, api_affineTransformation_n_ = _ivectordouble(affineTransformation)
            ierr = c_int()
            lib.gmshModelMeshSetPeriodic(
                c_int(dim),
                api_tags_, api_tags_n_,
                api_tagsSource_, api_tagsSource_n_,
                api_affineTransformation_, api_affineTransformation_n_,
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelMeshSetPeriodic returned non-zero error code: ",
                    ierr.value)


        class field:
            """
            Per-model mesh size field functions
            """

            @staticmethod
            def add(type, tag=-1):
                """
                Adds a new mesh size field of type `type'. If `tag' is positive, assigns
                the tag explcitly; otherwise a new tag is assigned automatically. Returns
                the field tag.

                Returns an integer.
                """
                ierr = c_int()
                api__result__ = lib.gmshModelMeshFieldAdd(
                    c_char_p(type.encode()),
                    c_int(tag),
                    byref(ierr))
                if ierr.value != 0:
                    raise ValueError(
                        "gmshModelMeshFieldAdd returned non-zero error code: ",
                        ierr.value)
                return api__result__

            @staticmethod
            def remove(tag):
                """
                Removes the field with tag `tag'.
                """
                ierr = c_int()
                lib.gmshModelMeshFieldRemove(
                    c_int(tag),
                    byref(ierr))
                if ierr.value != 0:
                    raise ValueError(
                        "gmshModelMeshFieldRemove returned non-zero error code: ",
                        ierr.value)

            @staticmethod
            def setNumber(tag, option, value):
                """
                Sets the numerical option `option' to value `value' for field `tag'.
                """
                ierr = c_int()
                lib.gmshModelMeshFieldSetNumber(
                    c_int(tag),
                    c_char_p(option.encode()),
                    c_double(value),
                    byref(ierr))
                if ierr.value != 0:
                    raise ValueError(
                        "gmshModelMeshFieldSetNumber returned non-zero error code: ",
                        ierr.value)

            @staticmethod
            def setString(tag, option, value):
                """
                Sets the string option `option' to value `value' for field `tag'.
                """
                ierr = c_int()
                lib.gmshModelMeshFieldSetString(
                    c_int(tag),
                    c_char_p(option.encode()),
                    c_char_p(value.encode()),
                    byref(ierr))
                if ierr.value != 0:
                    raise ValueError(
                        "gmshModelMeshFieldSetString returned non-zero error code: ",
                        ierr.value)

            @staticmethod
            def setNumbers(tag, option, value):
                """
                Sets the numerical list option `option' to value `value' for field `tag'.
                """
                api_value_, api_value_n_ = _ivectordouble(value)
                ierr = c_int()
                lib.gmshModelMeshFieldSetNumbers(
                    c_int(tag),
                    c_char_p(option.encode()),
                    api_value_, api_value_n_,
                    byref(ierr))
                if ierr.value != 0:
                    raise ValueError(
                        "gmshModelMeshFieldSetNumbers returned non-zero error code: ",
                        ierr.value)

            @staticmethod
            def setAsBackgroundMesh(tag):
                """
                Sets the field `tag' as the background mesh size field.
                """
                ierr = c_int()
                lib.gmshModelMeshFieldSetAsBackgroundMesh(
                    c_int(tag),
                    byref(ierr))
                if ierr.value != 0:
                    raise ValueError(
                        "gmshModelMeshFieldSetAsBackgroundMesh returned non-zero error code: ",
                        ierr.value)

            @staticmethod
            def setAsBoundaryLayer(tag):
                """
                Sets the field `tag' as a boundary layer size field.
                """
                ierr = c_int()
                lib.gmshModelMeshFieldSetAsBoundaryLayer(
                    c_int(tag),
                    byref(ierr))
                if ierr.value != 0:
                    raise ValueError(
                        "gmshModelMeshFieldSetAsBoundaryLayer returned non-zero error code: ",
                        ierr.value)


    class geo:
        """
        Internal per-model GEO CAD kernel functions
        """

        @staticmethod
        def addPoint(x, y, z, meshSize=0., tag=-1):
            """
            Adds a geometrical point in the internal GEO CAD representation, at
            coordinates (x, y, z). If `meshSize' is > 0, adds a meshing constraint at
            that point. If `tag' is positive, sets the tag explicitly; otherwise a new
            tag is selected automatically. Returns the tag of the point. (Note that the
            point will be added in the current model only after `synchronize' is
            called. This behavior holds for all the entities added in the geo module.)

            Returns an integer.
            """
            ierr = c_int()
            api__result__ = lib.gmshModelGeoAddPoint(
                c_double(x),
                c_double(y),
                c_double(z),
                c_double(meshSize),
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelGeoAddPoint returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addLine(startTag, endTag, tag=-1):
            """
            Adds a straight line segment between the two points with tags `startTag'
            and `endTag'. If `tag' is positive, sets the tag explicitly; otherwise a
            new tag is selected automatically. Returns the tag of the line.

            Returns an integer.
            """
            ierr = c_int()
            api__result__ = lib.gmshModelGeoAddLine(
                c_int(startTag),
                c_int(endTag),
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelGeoAddLine returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addCircleArc(startTag, centerTag, endTag, tag=-1, nx=0., ny=0., nz=0.):
            """
            Adds a circle arc (stricly smaller than Pi) between the two points with
            tags `startTag' and `endTag', with center `centertag'. If `tag' is
            positive, sets the tag explicitly; otherwise a new tag is selected
            automatically. If (`nx', `ny', `nz') != (0,0,0), explicitely sets the plane
            of the circle arc. Returns the tag of the circle arc.

            Returns an integer.
            """
            ierr = c_int()
            api__result__ = lib.gmshModelGeoAddCircleArc(
                c_int(startTag),
                c_int(centerTag),
                c_int(endTag),
                c_int(tag),
                c_double(nx),
                c_double(ny),
                c_double(nz),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelGeoAddCircleArc returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addEllipseArc(startTag, centerTag, majorTag, endTag, tag=-1, nx=0., ny=0., nz=0.):
            """
            Adds an ellipse arc (stricly smaller than Pi) between the two points
            `startTag' and `endTag', with center `centertag' and major axis point
            `majorTag'. If `tag' is positive, sets the tag explicitly; otherwise a new
            tag is selected automatically. If (`nx', `ny', `nz') != (0,0,0),
            explicitely sets the plane of the circle arc. Returns the tag of the
            ellipse arc.

            Returns an integer.
            """
            ierr = c_int()
            api__result__ = lib.gmshModelGeoAddEllipseArc(
                c_int(startTag),
                c_int(centerTag),
                c_int(majorTag),
                c_int(endTag),
                c_int(tag),
                c_double(nx),
                c_double(ny),
                c_double(nz),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelGeoAddEllipseArc returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addSpline(pointTags, tag=-1):
            """
            Adds a spline (Catmull-Rom) curve going through the points `pointTags'. If
            `tag' is positive, sets the tag explicitly; otherwise a new tag is selected
            automatically. Creates a periodic curve if the first and last points are
            the same. Returns the tag of the spline curve.

            Returns an integer.
            """
            api_pointTags_, api_pointTags_n_ = _ivectorint(pointTags)
            ierr = c_int()
            api__result__ = lib.gmshModelGeoAddSpline(
                api_pointTags_, api_pointTags_n_,
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelGeoAddSpline returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addBSpline(pointTags, tag=-1):
            """
            Adds a cubic b-spline curve with `pointTags' control points. If `tag' is
            positive, sets the tag explicitly; otherwise a new tag is selected
            automatically. Creates a periodic curve if the first and last points are
            the same. Returns the tag of the b-spline curve.

            Returns an integer.
            """
            api_pointTags_, api_pointTags_n_ = _ivectorint(pointTags)
            ierr = c_int()
            api__result__ = lib.gmshModelGeoAddBSpline(
                api_pointTags_, api_pointTags_n_,
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelGeoAddBSpline returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addBezier(pointTags, tag=-1):
            """
            Adds a Bezier curve with `pointTags' control points. If `tag' is positive,
            sets the tag explicitly; otherwise a new tag is selected automatically.
            Returns the tag of the Bezier curve.

            Returns an integer.
            """
            api_pointTags_, api_pointTags_n_ = _ivectorint(pointTags)
            ierr = c_int()
            api__result__ = lib.gmshModelGeoAddBezier(
                api_pointTags_, api_pointTags_n_,
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelGeoAddBezier returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addCurveLoop(curveTags, tag=-1):
            """
            Adds a curve loop (a closed wire) formed by the curves `curveTags'.
            `curveTags' should contain (signed) tags of geometrical enties of dimension
            1 forming a closed loop: a negative tag signifies that the underlying curve
            is considered with reversed orientation. If `tag' is positive, sets the tag
            explicitly; otherwise a new tag is selected automatically. Returns the tag
            of the curve loop.

            Returns an integer.
            """
            api_curveTags_, api_curveTags_n_ = _ivectorint(curveTags)
            ierr = c_int()
            api__result__ = lib.gmshModelGeoAddCurveLoop(
                api_curveTags_, api_curveTags_n_,
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelGeoAddCurveLoop returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addPlaneSurface(wireTags, tag=-1):
            """
            Adds a plane surface defined by one or more curve loops `wireTags'. The
            first curve loop defines the exterior contour; additional curve loop define
            holes. If `tag' is positive, sets the tag explicitly; otherwise a new tag
            is selected automatically. Returns the tag of the surface.

            Returns an integer.
            """
            api_wireTags_, api_wireTags_n_ = _ivectorint(wireTags)
            ierr = c_int()
            api__result__ = lib.gmshModelGeoAddPlaneSurface(
                api_wireTags_, api_wireTags_n_,
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelGeoAddPlaneSurface returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addSurfaceFilling(wireTags, tag=-1, sphereCenterTag=-1):
            """
            Adds a surface filling the curve loops in `wireTags'. Currently only a
            single curve loop is supported; this curve loop should be composed by 3 or
            4 curves only. If `tag' is positive, sets the tag explicitly; otherwise a
            new tag is selected automatically. Returns the tag of the surface.

            Returns an integer.
            """
            api_wireTags_, api_wireTags_n_ = _ivectorint(wireTags)
            ierr = c_int()
            api__result__ = lib.gmshModelGeoAddSurfaceFilling(
                api_wireTags_, api_wireTags_n_,
                c_int(tag),
                c_int(sphereCenterTag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelGeoAddSurfaceFilling returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addSurfaceLoop(surfaceTags, tag=-1):
            """
            Adds a surface loop (a closed shell) formed by `surfaceTags'.  If `tag' is
            positive, sets the tag explicitly; otherwise a new tag is selected
            automatically. Returns the tag of the shell.

            Returns an integer.
            """
            api_surfaceTags_, api_surfaceTags_n_ = _ivectorint(surfaceTags)
            ierr = c_int()
            api__result__ = lib.gmshModelGeoAddSurfaceLoop(
                api_surfaceTags_, api_surfaceTags_n_,
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelGeoAddSurfaceLoop returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addVolume(shellTags, tag=-1):
            """
            Adds a volume (a region) defined by one or more shells `shellTags'. The
            first surface loop defines the exterior boundary; additional surface loop
            define holes. If `tag' is positive, sets the tag explicitly; otherwise a
            new tag is selected automatically. Returns the tag of the volume.

            Returns an integer.
            """
            api_shellTags_, api_shellTags_n_ = _ivectorint(shellTags)
            ierr = c_int()
            api__result__ = lib.gmshModelGeoAddVolume(
                api_shellTags_, api_shellTags_n_,
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelGeoAddVolume returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def extrude(dimTags, dx, dy, dz, numElements=[], heights=[], recombine=False):
            """
            Extrudes the geometrical entities `dimTags' by translation along (`dx',
            `dy', `dz'). Returns extruded entities in `outDimTags'. If `numElements' is
            not empty, also extrude the mesh: the entries in `numElements' give the
            number of elements in each layer. If `height' is not empty, it provides the
            (cummulative) height of the different layers, normalized to 1.

            Returns `outDimTags'.
            """
            api_dimTags_, api_dimTags_n_ = _ivectorpair(dimTags)
            api_outDimTags_, api_outDimTags_n_ = POINTER(c_int)(), c_size_t()
            api_numElements_, api_numElements_n_ = _ivectorint(numElements)
            api_heights_, api_heights_n_ = _ivectordouble(heights)
            ierr = c_int()
            lib.gmshModelGeoExtrude(
                api_dimTags_, api_dimTags_n_,
                c_double(dx),
                c_double(dy),
                c_double(dz),
                byref(api_outDimTags_), byref(api_outDimTags_n_),
                api_numElements_, api_numElements_n_,
                api_heights_, api_heights_n_,
                c_int(bool(recombine)),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelGeoExtrude returned non-zero error code: ",
                    ierr.value)
            return _ovectorpair(api_outDimTags_, api_outDimTags_n_.value)

        @staticmethod
        def revolve(dimTags, x, y, z, ax, ay, az, angle, numElements=[], heights=[], recombine=False):
            """
            Extrudes the geometrical entities `dimTags' by rotation of `angle' radians
            around the axis of revolution defined by the point (`x', `y', `z') and the
            direction (`ax', `ay', `az'). Returns extruded entities in `outDimTags'. If
            `numElements' is not empty, also extrude the mesh: the entries in
            `numElements' give the number of elements in each layer. If `height' is not
            empty, it provides the (cummulative) height of the different layers,
            normalized to 1.

            Returns `outDimTags'.
            """
            api_dimTags_, api_dimTags_n_ = _ivectorpair(dimTags)
            api_outDimTags_, api_outDimTags_n_ = POINTER(c_int)(), c_size_t()
            api_numElements_, api_numElements_n_ = _ivectorint(numElements)
            api_heights_, api_heights_n_ = _ivectordouble(heights)
            ierr = c_int()
            lib.gmshModelGeoRevolve(
                api_dimTags_, api_dimTags_n_,
                c_double(x),
                c_double(y),
                c_double(z),
                c_double(ax),
                c_double(ay),
                c_double(az),
                c_double(angle),
                byref(api_outDimTags_), byref(api_outDimTags_n_),
                api_numElements_, api_numElements_n_,
                api_heights_, api_heights_n_,
                c_int(bool(recombine)),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelGeoRevolve returned non-zero error code: ",
                    ierr.value)
            return _ovectorpair(api_outDimTags_, api_outDimTags_n_.value)

        @staticmethod
        def twist(dimTags, x, y, z, dx, dy, dz, ax, ay, az, angle, numElements=[], heights=[], recombine=False):
            """
            Extrudes the geometrical entities `dimTags' by a combined translation and
            rotation of `angle' radians, along (`dx', `dy', `dz') and around the axis
            of revolution defined by the point (`x', `y', `z') and the direction (`ax',
            `ay', `az'). Returns extruded entities in `outDimTags'. If `numElements' is
            not empty, also extrude the mesh: the entries in `numElements' give the
            number of elements in each layer. If `height' is not empty, it provides the
            (cummulative) height of the different layers, normalized to 1.

            Returns `outDimTags'.
            """
            api_dimTags_, api_dimTags_n_ = _ivectorpair(dimTags)
            api_outDimTags_, api_outDimTags_n_ = POINTER(c_int)(), c_size_t()
            api_numElements_, api_numElements_n_ = _ivectorint(numElements)
            api_heights_, api_heights_n_ = _ivectordouble(heights)
            ierr = c_int()
            lib.gmshModelGeoTwist(
                api_dimTags_, api_dimTags_n_,
                c_double(x),
                c_double(y),
                c_double(z),
                c_double(dx),
                c_double(dy),
                c_double(dz),
                c_double(ax),
                c_double(ay),
                c_double(az),
                c_double(angle),
                byref(api_outDimTags_), byref(api_outDimTags_n_),
                api_numElements_, api_numElements_n_,
                api_heights_, api_heights_n_,
                c_int(bool(recombine)),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelGeoTwist returned non-zero error code: ",
                    ierr.value)
            return _ovectorpair(api_outDimTags_, api_outDimTags_n_.value)

        @staticmethod
        def translate(dimTags, dx, dy, dz):
            """
            Translates the geometrical entities `dimTags' along (`dx', `dy', `dz').
            """
            api_dimTags_, api_dimTags_n_ = _ivectorpair(dimTags)
            ierr = c_int()
            lib.gmshModelGeoTranslate(
                api_dimTags_, api_dimTags_n_,
                c_double(dx),
                c_double(dy),
                c_double(dz),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelGeoTranslate returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def rotate(dimTags, x, y, z, ax, ay, az, angle):
            """
            Rotates the geometrical entities `dimTags' of `angle' radians around the
            axis of revolution defined by the point (`x', `y', `z') and the direction
            (`ax', `ay', `az').
            """
            api_dimTags_, api_dimTags_n_ = _ivectorpair(dimTags)
            ierr = c_int()
            lib.gmshModelGeoRotate(
                api_dimTags_, api_dimTags_n_,
                c_double(x),
                c_double(y),
                c_double(z),
                c_double(ax),
                c_double(ay),
                c_double(az),
                c_double(angle),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelGeoRotate returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def dilate(dimTags, x, y, z, a, b, c):
            """
            Scales the geometrical entities `dimTag' by factors `a', `b' and `c' along
            the three coordinate axes; use (`x', `y', `z') as the center of the
            homothetic transformation.
            """
            api_dimTags_, api_dimTags_n_ = _ivectorpair(dimTags)
            ierr = c_int()
            lib.gmshModelGeoDilate(
                api_dimTags_, api_dimTags_n_,
                c_double(x),
                c_double(y),
                c_double(z),
                c_double(a),
                c_double(b),
                c_double(c),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelGeoDilate returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def symmetry(dimTags, a, b, c, d):
            """
            Applies a symmetry transformation to the geometrical entities `dimTag',
            with respect to the plane of equation `a' * x + `b' * y + `c' * z + `d' =
            0.
            """
            api_dimTags_, api_dimTags_n_ = _ivectorpair(dimTags)
            ierr = c_int()
            lib.gmshModelGeoSymmetry(
                api_dimTags_, api_dimTags_n_,
                c_double(a),
                c_double(b),
                c_double(c),
                c_double(d),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelGeoSymmetry returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def copy(dimTags):
            """
            Copies the entities `dimTags'; the new entities are returned in
            `outDimTags'.

            Returns `outDimTags'.
            """
            api_dimTags_, api_dimTags_n_ = _ivectorpair(dimTags)
            api_outDimTags_, api_outDimTags_n_ = POINTER(c_int)(), c_size_t()
            ierr = c_int()
            lib.gmshModelGeoCopy(
                api_dimTags_, api_dimTags_n_,
                byref(api_outDimTags_), byref(api_outDimTags_n_),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelGeoCopy returned non-zero error code: ",
                    ierr.value)
            return _ovectorpair(api_outDimTags_, api_outDimTags_n_.value)

        @staticmethod
        def remove(dimTags, recursive=False):
            """
            Removes the entities `dimTags'. If `recursive' is true, removes all the
            entities on their boundaries, down to dimension 0.
            """
            api_dimTags_, api_dimTags_n_ = _ivectorpair(dimTags)
            ierr = c_int()
            lib.gmshModelGeoRemove(
                api_dimTags_, api_dimTags_n_,
                c_int(bool(recursive)),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelGeoRemove returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def removeAllDuplicates():
            """
            Removes all duplicate entities (different entities at the same geometrical
            location).
            """
            ierr = c_int()
            lib.gmshModelGeoRemoveAllDuplicates(
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelGeoRemoveAllDuplicates returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def synchronize():
            """
            Synchronize the internal GEO CAD representation with the current Gmsh
            model. This can be called at any time, but since it involves a non trivial
            amount of processing, the number of synchronization points should normally
            be minimized.
            """
            ierr = c_int()
            lib.gmshModelGeoSynchronize(
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelGeoSynchronize returned non-zero error code: ",
                    ierr.value)


        class mesh:
            """
            GEO-specific meshing constraints
            """

            @staticmethod
            def setSize(dimTags, size):
                """
                Sets a mesh size constraint on the geometrical entities `dimTags'.
                Currently only entities of dimension 0 (points) are handled.
                """
                api_dimTags_, api_dimTags_n_ = _ivectorpair(dimTags)
                ierr = c_int()
                lib.gmshModelGeoMeshSetSize(
                    api_dimTags_, api_dimTags_n_,
                    c_double(size),
                    byref(ierr))
                if ierr.value != 0:
                    raise ValueError(
                        "gmshModelGeoMeshSetSize returned non-zero error code: ",
                        ierr.value)

            @staticmethod
            def setTransfiniteCurve(tag, nPoints, type="Progression", coef=1.):
                """
                Sets a transfinite meshing constraint on the curve `tag', with `numNodes'
                mesh nodes distributed according to `type' and `coef'. Currently supported
                types are "Progression" (geometrical progression with power `coef') and
                "Bump" (refinement toward both extreminties of the curve).
                """
                ierr = c_int()
                lib.gmshModelGeoMeshSetTransfiniteCurve(
                    c_int(tag),
                    c_int(nPoints),
                    c_char_p(type.encode()),
                    c_double(coef),
                    byref(ierr))
                if ierr.value != 0:
                    raise ValueError(
                        "gmshModelGeoMeshSetTransfiniteCurve returned non-zero error code: ",
                        ierr.value)

            @staticmethod
            def setTransfiniteSurface(tag, arrangement="Left", cornerTags=[]):
                """
                Sets a transfinite meshing constraint on the surface `tag'. `arrangement'
                describes the arrangement of the triangles when the surface is not flagged
                as recombined: currently supported values are "Left", "Right",
                "AlternateLeft" and "AlternateRight". `cornerTags' can be used to specify
                the (3 or 4) corners of the transfinite interpolation explicitly;
                specifying the corners explicitly is mandatory if the surface has more that
                3 or 4 points on its boundary.
                """
                api_cornerTags_, api_cornerTags_n_ = _ivectorint(cornerTags)
                ierr = c_int()
                lib.gmshModelGeoMeshSetTransfiniteSurface(
                    c_int(tag),
                    c_char_p(arrangement.encode()),
                    api_cornerTags_, api_cornerTags_n_,
                    byref(ierr))
                if ierr.value != 0:
                    raise ValueError(
                        "gmshModelGeoMeshSetTransfiniteSurface returned non-zero error code: ",
                        ierr.value)

            @staticmethod
            def setTransfiniteVolume(tag, cornerTags=[]):
                """
                Sets a transfinite meshing constraint on the surface `tag'. `cornerTags'
                can be used to specify the (6 or 8) corners of the transfinite
                interpolation explicitly.
                """
                api_cornerTags_, api_cornerTags_n_ = _ivectorint(cornerTags)
                ierr = c_int()
                lib.gmshModelGeoMeshSetTransfiniteVolume(
                    c_int(tag),
                    api_cornerTags_, api_cornerTags_n_,
                    byref(ierr))
                if ierr.value != 0:
                    raise ValueError(
                        "gmshModelGeoMeshSetTransfiniteVolume returned non-zero error code: ",
                        ierr.value)

            @staticmethod
            def setRecombine(dim, tag, angle=45.):
                """
                Sets a recombination meshing constraint on the geometrical entity of
                dimension `dim' and tag `tag'. Currently only entities of dimension 2 (to
                recombine triangles into quadrangles) are supported.
                """
                ierr = c_int()
                lib.gmshModelGeoMeshSetRecombine(
                    c_int(dim),
                    c_int(tag),
                    c_double(angle),
                    byref(ierr))
                if ierr.value != 0:
                    raise ValueError(
                        "gmshModelGeoMeshSetRecombine returned non-zero error code: ",
                        ierr.value)

            @staticmethod
            def setSmoothing(dim, tag, val):
                """
                Sets a smoothing meshing constraint on the geometrical entity of dimension
                `dim' and tag `tag'. `val' iterations of a Laplace smoother are applied.
                """
                ierr = c_int()
                lib.gmshModelGeoMeshSetSmoothing(
                    c_int(dim),
                    c_int(tag),
                    c_int(val),
                    byref(ierr))
                if ierr.value != 0:
                    raise ValueError(
                        "gmshModelGeoMeshSetSmoothing returned non-zero error code: ",
                        ierr.value)

            @staticmethod
            def setReverse(dim, tag, val=True):
                """
                Sets a reverse meshing constraint on the geometrical entity of dimension
                `dim' and tag `tag'. If `val' is true, the mesh orientation will be
                reversed with respect to the natural mesh orientation (i.e. the orientation
                consistent with the orientation of the geometrical entity). If `val' is
                false, the mesh is left as-is.
                """
                ierr = c_int()
                lib.gmshModelGeoMeshSetReverse(
                    c_int(dim),
                    c_int(tag),
                    c_int(bool(val)),
                    byref(ierr))
                if ierr.value != 0:
                    raise ValueError(
                        "gmshModelGeoMeshSetReverse returned non-zero error code: ",
                        ierr.value)


    class occ:
        """
        Internal per-model OpenCASCADE CAD kernel functions
        """

        @staticmethod
        def addPoint(x, y, z, meshSize=0., tag=-1):
            """
            Adds a geometrical point in the internal OpenCASCADE CAD representation, at
            coordinates (x, y, z). If `meshSize' is > 0, adds a meshing constraint at
            that point. If `tag' is positive, sets the tag explicitly; otherwise a new
            tag is selected automatically. Returns the tag of the point. (Note that the
            point will be added in the current model only after `synchronize' is
            called. This behavior holds for all the entities added in the occ module.)

            Returns an integer.
            """
            ierr = c_int()
            api__result__ = lib.gmshModelOccAddPoint(
                c_double(x),
                c_double(y),
                c_double(z),
                c_double(meshSize),
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddPoint returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addLine(startTag, endTag, tag=-1):
            """
            Adds a straight line segment between the two points with tags `startTag'
            and `endTag'. If `tag' is positive, sets the tag explicitly; otherwise a
            new tag is selected automatically. Returns the tag of the line.

            Returns an integer.
            """
            ierr = c_int()
            api__result__ = lib.gmshModelOccAddLine(
                c_int(startTag),
                c_int(endTag),
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddLine returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addCircleArc(startTag, centerTag, endTag, tag=-1):
            """
            Adds a circle arc between the two points with tags `startTag' and `endTag',
            with center `centerTag'. If `tag' is positive, sets the tag explicitly;
            otherwise a new tag is selected automatically. Returns the tag of the
            circle arc.

            Returns an integer.
            """
            ierr = c_int()
            api__result__ = lib.gmshModelOccAddCircleArc(
                c_int(startTag),
                c_int(centerTag),
                c_int(endTag),
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddCircleArc returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addCircle(x, y, z, r, tag=-1, angle1=0., angle2=2*pi):
            """
            Adds a circle of center (`x', `y', `z') and radius `r'. If `tag' is
            positive, sets the tag explicitly; otherwise a new tag is selected
            automatically. If `angle1' and `angle2' are specified, creates a circle arc
            between the two angles. Returns the tag of the circle.

            Returns an integer.
            """
            ierr = c_int()
            api__result__ = lib.gmshModelOccAddCircle(
                c_double(x),
                c_double(y),
                c_double(z),
                c_double(r),
                c_int(tag),
                c_double(angle1),
                c_double(angle2),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddCircle returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addEllipseArc(startTag, centerTag, endTag, tag=-1):
            """
            Adds an ellipse arc between the two points with tags `startTag' and
            `endTag', with center `centerTag'. If `tag' is positive, sets the tag
            explicitly; otherwise a new tag is selected automatically. Returns the tag
            of the ellipse arc.

            Returns an integer.
            """
            ierr = c_int()
            api__result__ = lib.gmshModelOccAddEllipseArc(
                c_int(startTag),
                c_int(centerTag),
                c_int(endTag),
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddEllipseArc returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addEllipse(x, y, z, r1, r2, tag=-1, angle1=0., angle2=2*pi):
            """
            Adds an ellipse of center (`x', `y', `z') and radii `r1' and `r2' along the
            x- and y-axes respectively. If `tag' is positive, sets the tag explicitly;
            otherwise a new tag is selected automatically. If `angle1' and `angle2' are
            specified, creates an ellipse arc between the two angles. Returns the tag
            of the ellipse.

            Returns an integer.
            """
            ierr = c_int()
            api__result__ = lib.gmshModelOccAddEllipse(
                c_double(x),
                c_double(y),
                c_double(z),
                c_double(r1),
                c_double(r2),
                c_int(tag),
                c_double(angle1),
                c_double(angle2),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddEllipse returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addSpline(pointTags, tag=-1):
            """
            Adds a spline (C2 b-spline) curve going through the points `pointTags'. If
            `tag' is positive, sets the tag explicitly; otherwise a new tag is selected
            automatically. Creates a periodic curve if the first and last points are
            the same. Returns the tag of the spline curve.

            Returns an integer.
            """
            api_pointTags_, api_pointTags_n_ = _ivectorint(pointTags)
            ierr = c_int()
            api__result__ = lib.gmshModelOccAddSpline(
                api_pointTags_, api_pointTags_n_,
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddSpline returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addBSpline(pointTags, tag=-1, degree=3, weights=[], knots=[], multiplicities=[]):
            """
            Adds a b-spline curve of degree `degree' with `pointTags' control points.
            If `weights', `knots' or `multiplicities' are not provided, default
            parameters are computed automatically. If `tag' is positive, sets the tag
            explicitly; otherwise a new tag is selected automatically. Creates a
            periodic curve if the first and last points are the same. Returns the tag
            of the b-spline curve.

            Returns an integer.
            """
            api_pointTags_, api_pointTags_n_ = _ivectorint(pointTags)
            api_weights_, api_weights_n_ = _ivectordouble(weights)
            api_knots_, api_knots_n_ = _ivectordouble(knots)
            api_multiplicities_, api_multiplicities_n_ = _ivectorint(multiplicities)
            ierr = c_int()
            api__result__ = lib.gmshModelOccAddBSpline(
                api_pointTags_, api_pointTags_n_,
                c_int(tag),
                c_int(degree),
                api_weights_, api_weights_n_,
                api_knots_, api_knots_n_,
                api_multiplicities_, api_multiplicities_n_,
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddBSpline returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addBezier(pointTags, tag=-1):
            """
            Adds a Bezier curve with `pointTags' control points. If `tag' is positive,
            sets the tag explicitly; otherwise a new tag is selected automatically.
            Returns the tag of the Bezier curve.

            Returns an integer.
            """
            api_pointTags_, api_pointTags_n_ = _ivectorint(pointTags)
            ierr = c_int()
            api__result__ = lib.gmshModelOccAddBezier(
                api_pointTags_, api_pointTags_n_,
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddBezier returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addWire(curveTags, tag=-1, checkClosed=False):
            """
            Adds a wire (open or closed) formed by the curves `curveTags'. `curveTags'
            should contain (signed) tags: a negative tag signifies that the underlying
            curve is considered with reversed orientation. If `tag' is positive, sets
            the tag explicitly; otherwise a new tag is selected automatically. Returns
            the tag of the wire.

            Returns an integer.
            """
            api_curveTags_, api_curveTags_n_ = _ivectorint(curveTags)
            ierr = c_int()
            api__result__ = lib.gmshModelOccAddWire(
                api_curveTags_, api_curveTags_n_,
                c_int(tag),
                c_int(bool(checkClosed)),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddWire returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addCurveLoop(curveTags, tag=-1):
            """
            Adds a curve loop (a closed wire) formed by the curves `curveTags'.
            `curveTags' should contain (signed) tags of curves forming a closed loop: a
            negative tag signifies that the underlying curve is considered with
            reversed orientation. If `tag' is positive, sets the tag explicitly;
            otherwise a new tag is selected automatically. Returns the tag of the curve
            loop.

            Returns an integer.
            """
            api_curveTags_, api_curveTags_n_ = _ivectorint(curveTags)
            ierr = c_int()
            api__result__ = lib.gmshModelOccAddCurveLoop(
                api_curveTags_, api_curveTags_n_,
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddCurveLoop returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addRectangle(x, y, z, dx, dy, tag=-1, roundedRadius=0.):
            """
            Adds a rectangle with lower left corner at (`x', `y', `z') and upper right
            corner at (`x' + `dx', `y' + `dy', `z'). If `tag' is positive, sets the tag
            explicitly; otherwise a new tag is selected automatically. Rounds the
            corners if `roundedRadius' is nonzero. Returns the tag of the rectangle.

            Returns an integer.
            """
            ierr = c_int()
            api__result__ = lib.gmshModelOccAddRectangle(
                c_double(x),
                c_double(y),
                c_double(z),
                c_double(dx),
                c_double(dy),
                c_int(tag),
                c_double(roundedRadius),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddRectangle returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addDisk(xc, yc, zc, rx, ry, tag=-1):
            """
            Adds a disk with center (`xc', `yc', `zc') and radius `rx' along the x-axis
            and `ry' along the y-axis. If `tag' is positive, sets the tag explicitly;
            otherwise a new tag is selected automatically. Returns the tag of the disk.

            Returns an integer.
            """
            ierr = c_int()
            api__result__ = lib.gmshModelOccAddDisk(
                c_double(xc),
                c_double(yc),
                c_double(zc),
                c_double(rx),
                c_double(ry),
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddDisk returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addPlaneSurface(wireTags, tag=-1):
            """
            Adds a plane surface defined by one or more curve loops (or closed wires)
            `wireTags'. The first curve loop defines the exterior contour; additional
            curve loop define holes. If `tag' is positive, sets the tag explicitly;
            otherwise a new tag is selected automatically. Returns the tag of the
            surface.

            Returns an integer.
            """
            api_wireTags_, api_wireTags_n_ = _ivectorint(wireTags)
            ierr = c_int()
            api__result__ = lib.gmshModelOccAddPlaneSurface(
                api_wireTags_, api_wireTags_n_,
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddPlaneSurface returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addSurfaceFilling(wireTag, tag=-1):
            """
            Adds a surface filling the curve loops in `wireTags'. If `tag' is positive,
            sets the tag explicitly; otherwise a new tag is selected automatically.
            Returns the tag of the surface.

            Returns an integer.
            """
            ierr = c_int()
            api__result__ = lib.gmshModelOccAddSurfaceFilling(
                c_int(wireTag),
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddSurfaceFilling returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addSurfaceLoop(surfaceTags, tag=-1):
            """
            Adds a surface loop (a closed shell) formed by `surfaceTags'.  If `tag' is
            positive, sets the tag explicitly; otherwise a new tag is selected
            automatically. Returns the tag of the surface loop.

            Returns an integer.
            """
            api_surfaceTags_, api_surfaceTags_n_ = _ivectorint(surfaceTags)
            ierr = c_int()
            api__result__ = lib.gmshModelOccAddSurfaceLoop(
                api_surfaceTags_, api_surfaceTags_n_,
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddSurfaceLoop returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addVolume(shellTags, tag=-1):
            """
            Adds a volume (a region) defined by one or more surface loops `shellTags'.
            The first surface loop defines the exterior boundary; additional surface
            loop define holes. If `tag' is positive, sets the tag explicitly; otherwise
            a new tag is selected automatically. Returns the tag of the volume.

            Returns an integer.
            """
            api_shellTags_, api_shellTags_n_ = _ivectorint(shellTags)
            ierr = c_int()
            api__result__ = lib.gmshModelOccAddVolume(
                api_shellTags_, api_shellTags_n_,
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddVolume returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addSphere(xc, yc, zc, radius, tag=-1, angle1=-pi/2, angle2=pi/2, angle3=2*pi):
            """
            Adds a sphere of center (`xc', `yc', `zc') and radius `r'. The optional
            `angle1' and `angle2' arguments define the polar angle opening (from -Pi/2
            to Pi/2). The optional `angle3' argument defines the azimuthal opening
            (from 0 to 2*Pi). If `tag' is positive, sets the tag explicitly; otherwise
            a new tag is selected automatically. Returns the tag of the sphere.

            Returns an integer.
            """
            ierr = c_int()
            api__result__ = lib.gmshModelOccAddSphere(
                c_double(xc),
                c_double(yc),
                c_double(zc),
                c_double(radius),
                c_int(tag),
                c_double(angle1),
                c_double(angle2),
                c_double(angle3),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddSphere returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addBox(x, y, z, dx, dy, dz, tag=-1):
            """
            Adds a parallelepipedic box defined by a point (`x', `y', `z') and the
            extents along the x-, y- and z-axes. If `tag' is positive, sets the tag
            explicitly; otherwise a new tag is selected automatically. Returns the tag
            of the box.

            Returns an integer.
            """
            ierr = c_int()
            api__result__ = lib.gmshModelOccAddBox(
                c_double(x),
                c_double(y),
                c_double(z),
                c_double(dx),
                c_double(dy),
                c_double(dz),
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddBox returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addCylinder(x, y, z, dx, dy, dz, r, tag=-1, angle=2*pi):
            """
            Adds a cylinder, defined by the center (`x', `y', `z') of its first
            circular face, the 3 components (`dx', `dy', `dz') of the vector defining
            its axis and its radius `r'. The optional `angle' argument defines the
            angular opening (from 0 to 2*Pi). If `tag' is positive, sets the tag
            explicitly; otherwise a new tag is selected automatically. Returns the tag
            of the cylinder.

            Returns an integer.
            """
            ierr = c_int()
            api__result__ = lib.gmshModelOccAddCylinder(
                c_double(x),
                c_double(y),
                c_double(z),
                c_double(dx),
                c_double(dy),
                c_double(dz),
                c_double(r),
                c_int(tag),
                c_double(angle),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddCylinder returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addCone(x, y, z, dx, dy, dz, r1, r2, tag=-1, angle=2*pi):
            """
            Adds a cone, defined by the center (`x', `y', `z') of its first circular
            face, the 3 components of the vector (`dx', `dy', `dz') defining its axis
            and the two radii `r1' and `r2' of the faces (these radii can be zero). If
            `tag' is positive, sets the tag explicitly; otherwise a new tag is selected
            automatically. `angle' defines the optional angular opening (from 0 to
            2*Pi). Returns the tag of the cone.

            Returns an integer.
            """
            ierr = c_int()
            api__result__ = lib.gmshModelOccAddCone(
                c_double(x),
                c_double(y),
                c_double(z),
                c_double(dx),
                c_double(dy),
                c_double(dz),
                c_double(r1),
                c_double(r2),
                c_int(tag),
                c_double(angle),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddCone returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addWedge(x, y, z, dx, dy, dz, tag=-1, ltx=0.):
            """
            Adds a right angular wedge, defined by the right-angle point (`x', `y',
            `z') and the 3 extends along the x-, y- and z-axes (`dx', `dy', `dz'). If
            `tag' is positive, sets the tag explicitly; otherwise a new tag is selected
            automatically. The optional argument `ltx' defines the top extent along the
            x-axis. Returns the tag of the wedge.

            Returns an integer.
            """
            ierr = c_int()
            api__result__ = lib.gmshModelOccAddWedge(
                c_double(x),
                c_double(y),
                c_double(z),
                c_double(dx),
                c_double(dy),
                c_double(dz),
                c_int(tag),
                c_double(ltx),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddWedge returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addTorus(x, y, z, r1, r2, tag=-1, angle=2*pi):
            """
            Adds a torus, defined by its center (`x', `y', `z') and its 2 radii `r' and
            `r2'. If `tag' is positive, sets the tag explicitly; otherwise a new tag is
            selected automatically. The optional argument `angle' defines the angular
            opening (from 0 to 2*Pi). Returns the tag of the wedge.

            Returns an integer.
            """
            ierr = c_int()
            api__result__ = lib.gmshModelOccAddTorus(
                c_double(x),
                c_double(y),
                c_double(z),
                c_double(r1),
                c_double(r2),
                c_int(tag),
                c_double(angle),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddTorus returned non-zero error code: ",
                    ierr.value)
            return api__result__

        @staticmethod
        def addThruSections(wireTags, tag=-1, makeSolid=True, makeRuled=False):
            """
            Adds a volume (if the optional argument `makeSolid' is set) or surfaces
            defined through the open or closed wires `wireTags'. If `tag' is positive,
            sets the tag explicitly; otherwise a new tag is selected automatically. The
            new entities are returned in `outDimTags'. If the optional argument
            `makeRuled' is set, the surfaces created on the boundary are forced to be
            ruled surfaces.

            Returns `outDimTags'.
            """
            api_wireTags_, api_wireTags_n_ = _ivectorint(wireTags)
            api_outDimTags_, api_outDimTags_n_ = POINTER(c_int)(), c_size_t()
            ierr = c_int()
            lib.gmshModelOccAddThruSections(
                api_wireTags_, api_wireTags_n_,
                byref(api_outDimTags_), byref(api_outDimTags_n_),
                c_int(tag),
                c_int(bool(makeSolid)),
                c_int(bool(makeRuled)),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddThruSections returned non-zero error code: ",
                    ierr.value)
            return _ovectorpair(api_outDimTags_, api_outDimTags_n_.value)

        @staticmethod
        def addThickSolid(volumeTag, excludeSurfaceTags, offset, tag=-1):
            """
            Adds a hollowed volume built from an initial volume `volumeTag' and a set
            of faces from this volume `excludeSurfaceTags', which are to be removed.
            The remaining faces of the volume become the walls of the hollowed solid,
            with thickness `offset'. If `tag' is positive, sets the tag explicitly;
            otherwise a new tag is selected automatically.

            Returns `outDimTags'.
            """
            api_excludeSurfaceTags_, api_excludeSurfaceTags_n_ = _ivectorint(excludeSurfaceTags)
            api_outDimTags_, api_outDimTags_n_ = POINTER(c_int)(), c_size_t()
            ierr = c_int()
            lib.gmshModelOccAddThickSolid(
                c_int(volumeTag),
                api_excludeSurfaceTags_, api_excludeSurfaceTags_n_,
                c_double(offset),
                byref(api_outDimTags_), byref(api_outDimTags_n_),
                c_int(tag),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddThickSolid returned non-zero error code: ",
                    ierr.value)
            return _ovectorpair(api_outDimTags_, api_outDimTags_n_.value)

        @staticmethod
        def extrude(dimTags, dx, dy, dz, numElements=[], heights=[], recombine=False):
            """
            Extrudes the geometrical entities `dimTags' by translation along (`dx',
            `dy', `dz'). Returns extruded entities in `outDimTags'. If `numElements' is
            not empty, also extrude the mesh: the entries in `numElements' give the
            number of elements in each layer. If `height' is not empty, it provides the
            (cummulative) height of the different layers, normalized to 1.

            Returns `outDimTags'.
            """
            api_dimTags_, api_dimTags_n_ = _ivectorpair(dimTags)
            api_outDimTags_, api_outDimTags_n_ = POINTER(c_int)(), c_size_t()
            api_numElements_, api_numElements_n_ = _ivectorint(numElements)
            api_heights_, api_heights_n_ = _ivectordouble(heights)
            ierr = c_int()
            lib.gmshModelOccExtrude(
                api_dimTags_, api_dimTags_n_,
                c_double(dx),
                c_double(dy),
                c_double(dz),
                byref(api_outDimTags_), byref(api_outDimTags_n_),
                api_numElements_, api_numElements_n_,
                api_heights_, api_heights_n_,
                c_int(bool(recombine)),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccExtrude returned non-zero error code: ",
                    ierr.value)
            return _ovectorpair(api_outDimTags_, api_outDimTags_n_.value)

        @staticmethod
        def revolve(dimTags, x, y, z, ax, ay, az, angle, numElements=[], heights=[], recombine=False):
            """
            Extrudes the geometrical entities `dimTags' by rotation of `angle' radians
            around the axis of revolution defined by the point (`x', `y', `z') and the
            direction (`ax', `ay', `az'). Returns extruded entities in `outDimTags'. If
            `numElements' is not empty, also extrude the mesh: the entries in
            `numElements' give the number of elements in each layer. If `height' is not
            empty, it provides the (cummulative) height of the different layers,
            normalized to 1.

            Returns `outDimTags'.
            """
            api_dimTags_, api_dimTags_n_ = _ivectorpair(dimTags)
            api_outDimTags_, api_outDimTags_n_ = POINTER(c_int)(), c_size_t()
            api_numElements_, api_numElements_n_ = _ivectorint(numElements)
            api_heights_, api_heights_n_ = _ivectordouble(heights)
            ierr = c_int()
            lib.gmshModelOccRevolve(
                api_dimTags_, api_dimTags_n_,
                c_double(x),
                c_double(y),
                c_double(z),
                c_double(ax),
                c_double(ay),
                c_double(az),
                c_double(angle),
                byref(api_outDimTags_), byref(api_outDimTags_n_),
                api_numElements_, api_numElements_n_,
                api_heights_, api_heights_n_,
                c_int(bool(recombine)),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccRevolve returned non-zero error code: ",
                    ierr.value)
            return _ovectorpair(api_outDimTags_, api_outDimTags_n_.value)

        @staticmethod
        def addPipe(dimTags, wireTag):
            """
            Adds a pipe by extruding the entities `dimTags' along the wire `wireTag'.
            Returns the pipe in `outDimTags'.

            Returns `outDimTags'.
            """
            api_dimTags_, api_dimTags_n_ = _ivectorpair(dimTags)
            api_outDimTags_, api_outDimTags_n_ = POINTER(c_int)(), c_size_t()
            ierr = c_int()
            lib.gmshModelOccAddPipe(
                api_dimTags_, api_dimTags_n_,
                c_int(wireTag),
                byref(api_outDimTags_), byref(api_outDimTags_n_),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccAddPipe returned non-zero error code: ",
                    ierr.value)
            return _ovectorpair(api_outDimTags_, api_outDimTags_n_.value)

        @staticmethod
        def fillet(volumeTags, curveTags, radius, removeVolume=True):
            """
            Fillets the volumes `volumeTags' on the curves `curveTags' with radius
            `radius'. Returns the filleted entities in `outDimTags'. Removes the
            original volume if `removeVolume' is set.

            Returns `outDimTags'.
            """
            api_volumeTags_, api_volumeTags_n_ = _ivectorint(volumeTags)
            api_curveTags_, api_curveTags_n_ = _ivectorint(curveTags)
            api_outDimTags_, api_outDimTags_n_ = POINTER(c_int)(), c_size_t()
            ierr = c_int()
            lib.gmshModelOccFillet(
                api_volumeTags_, api_volumeTags_n_,
                api_curveTags_, api_curveTags_n_,
                c_double(radius),
                byref(api_outDimTags_), byref(api_outDimTags_n_),
                c_int(bool(removeVolume)),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccFillet returned non-zero error code: ",
                    ierr.value)
            return _ovectorpair(api_outDimTags_, api_outDimTags_n_.value)

        @staticmethod
        def fuse(objectDimTags, toolDimTags, tag=-1, removeObject=True, removeTool=True):
            """
            Computes the boolean union (the fusion) of the entities `objectDimTags' and
            `toolDimTags'. Returns the resulting entities in `outDimTags'. If `tag' is
            positive, attemps to set the tag explicitly (ony valid if the boolean
            operation results in a single entity). Removes the object if `removeObject'
            is set. Removes the tool if `removeTool' is set.

            Returns `outDimTags', `outDimTagsMap'.
            """
            api_objectDimTags_, api_objectDimTags_n_ = _ivectorpair(objectDimTags)
            api_toolDimTags_, api_toolDimTags_n_ = _ivectorpair(toolDimTags)
            api_outDimTags_, api_outDimTags_n_ = POINTER(c_int)(), c_size_t()
            api_outDimTagsMap_, api_outDimTagsMap_n_, api_outDimTagsMap_nn_ = POINTER(POINTER(c_int))(), POINTER(c_size_t)(), c_size_t()
            ierr = c_int()
            lib.gmshModelOccFuse(
                api_objectDimTags_, api_objectDimTags_n_,
                api_toolDimTags_, api_toolDimTags_n_,
                byref(api_outDimTags_), byref(api_outDimTags_n_),
                byref(api_outDimTagsMap_), byref(api_outDimTagsMap_n_), byref(api_outDimTagsMap_nn_),
                c_int(tag),
                c_int(bool(removeObject)),
                c_int(bool(removeTool)),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccFuse returned non-zero error code: ",
                    ierr.value)
            return (
                _ovectorpair(api_outDimTags_, api_outDimTags_n_.value),
                _ovectorvectorpair(api_outDimTagsMap_, api_outDimTagsMap_n_, api_outDimTagsMap_nn_))

        @staticmethod
        def intersect(objectDimTags, toolDimTags, tag=-1, removeObject=True, removeTool=True):
            """
            Computes the boolean intersection (the common parts) of the entities
            `objectDimTags' and `toolDimTags'. Returns the resulting entities in
            `outDimTags'. If `tag' is positive, attemps to set the tag explicitly (ony
            valid if the boolean operation results in a single entity). Removes the
            object if `removeObject' is set. Removes the tool if `removeTool' is set.

            Returns `outDimTags', `outDimTagsMap'.
            """
            api_objectDimTags_, api_objectDimTags_n_ = _ivectorpair(objectDimTags)
            api_toolDimTags_, api_toolDimTags_n_ = _ivectorpair(toolDimTags)
            api_outDimTags_, api_outDimTags_n_ = POINTER(c_int)(), c_size_t()
            api_outDimTagsMap_, api_outDimTagsMap_n_, api_outDimTagsMap_nn_ = POINTER(POINTER(c_int))(), POINTER(c_size_t)(), c_size_t()
            ierr = c_int()
            lib.gmshModelOccIntersect(
                api_objectDimTags_, api_objectDimTags_n_,
                api_toolDimTags_, api_toolDimTags_n_,
                byref(api_outDimTags_), byref(api_outDimTags_n_),
                byref(api_outDimTagsMap_), byref(api_outDimTagsMap_n_), byref(api_outDimTagsMap_nn_),
                c_int(tag),
                c_int(bool(removeObject)),
                c_int(bool(removeTool)),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccIntersect returned non-zero error code: ",
                    ierr.value)
            return (
                _ovectorpair(api_outDimTags_, api_outDimTags_n_.value),
                _ovectorvectorpair(api_outDimTagsMap_, api_outDimTagsMap_n_, api_outDimTagsMap_nn_))

        @staticmethod
        def cut(objectDimTags, toolDimTags, tag=-1, removeObject=True, removeTool=True):
            """
            Computes the boolean difference between the entities `objectDimTags' and
            `toolDimTags'. Returns the resulting entities in `outDimTags'. If `tag' is
            positive, attemps to set the tag explicitly (ony valid if the boolean
            operation results in a single entity). Removes the object if `removeObject'
            is set. Removes the tool if `removeTool' is set.

            Returns `outDimTags', `outDimTagsMap'.
            """
            api_objectDimTags_, api_objectDimTags_n_ = _ivectorpair(objectDimTags)
            api_toolDimTags_, api_toolDimTags_n_ = _ivectorpair(toolDimTags)
            api_outDimTags_, api_outDimTags_n_ = POINTER(c_int)(), c_size_t()
            api_outDimTagsMap_, api_outDimTagsMap_n_, api_outDimTagsMap_nn_ = POINTER(POINTER(c_int))(), POINTER(c_size_t)(), c_size_t()
            ierr = c_int()
            lib.gmshModelOccCut(
                api_objectDimTags_, api_objectDimTags_n_,
                api_toolDimTags_, api_toolDimTags_n_,
                byref(api_outDimTags_), byref(api_outDimTags_n_),
                byref(api_outDimTagsMap_), byref(api_outDimTagsMap_n_), byref(api_outDimTagsMap_nn_),
                c_int(tag),
                c_int(bool(removeObject)),
                c_int(bool(removeTool)),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccCut returned non-zero error code: ",
                    ierr.value)
            return (
                _ovectorpair(api_outDimTags_, api_outDimTags_n_.value),
                _ovectorvectorpair(api_outDimTagsMap_, api_outDimTagsMap_n_, api_outDimTagsMap_nn_))

        @staticmethod
        def fragment(objectDimTags, toolDimTags, tag=-1, removeObject=True, removeTool=True):
            """
            Copmutes the boolean fragments (general fuse) of the entities
            `objectDimTags' and `toolDimTags'. Returns the resulting entities in
            `outDimTags'. If `tag' is positive, attemps to set the tag explicitly (ony
            valid if the boolean operation results in a single entity). Removes the
            object if `removeObject' is set. Removes the tool if `removeTool' is set.

            Returns `outDimTags', `outDimTagsMap'.
            """
            api_objectDimTags_, api_objectDimTags_n_ = _ivectorpair(objectDimTags)
            api_toolDimTags_, api_toolDimTags_n_ = _ivectorpair(toolDimTags)
            api_outDimTags_, api_outDimTags_n_ = POINTER(c_int)(), c_size_t()
            api_outDimTagsMap_, api_outDimTagsMap_n_, api_outDimTagsMap_nn_ = POINTER(POINTER(c_int))(), POINTER(c_size_t)(), c_size_t()
            ierr = c_int()
            lib.gmshModelOccFragment(
                api_objectDimTags_, api_objectDimTags_n_,
                api_toolDimTags_, api_toolDimTags_n_,
                byref(api_outDimTags_), byref(api_outDimTags_n_),
                byref(api_outDimTagsMap_), byref(api_outDimTagsMap_n_), byref(api_outDimTagsMap_nn_),
                c_int(tag),
                c_int(bool(removeObject)),
                c_int(bool(removeTool)),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccFragment returned non-zero error code: ",
                    ierr.value)
            return (
                _ovectorpair(api_outDimTags_, api_outDimTags_n_.value),
                _ovectorvectorpair(api_outDimTagsMap_, api_outDimTagsMap_n_, api_outDimTagsMap_nn_))

        @staticmethod
        def translate(dimTags, dx, dy, dz):
            """
            Translates the geometrical entities `dimTags' along (`dx', `dy', `dz').
            """
            api_dimTags_, api_dimTags_n_ = _ivectorpair(dimTags)
            ierr = c_int()
            lib.gmshModelOccTranslate(
                api_dimTags_, api_dimTags_n_,
                c_double(dx),
                c_double(dy),
                c_double(dz),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccTranslate returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def rotate(dimTags, x, y, z, ax, ay, az, angle):
            """
            Rotates the geometrical entities `dimTags' of `angle' radians around the
            axis of revolution defined by the point (`x', `y', `z') and the direction
            (`ax', `ay', `az').
            """
            api_dimTags_, api_dimTags_n_ = _ivectorpair(dimTags)
            ierr = c_int()
            lib.gmshModelOccRotate(
                api_dimTags_, api_dimTags_n_,
                c_double(x),
                c_double(y),
                c_double(z),
                c_double(ax),
                c_double(ay),
                c_double(az),
                c_double(angle),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccRotate returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def dilate(dimTags, x, y, z, a, b, c):
            """
            Scales the geometrical entities `dimTag' by factors `a', `b' and `c' along
            the three coordinate axes; use (`x', `y', `z') as the center of the
            homothetic transformation.
            """
            api_dimTags_, api_dimTags_n_ = _ivectorpair(dimTags)
            ierr = c_int()
            lib.gmshModelOccDilate(
                api_dimTags_, api_dimTags_n_,
                c_double(x),
                c_double(y),
                c_double(z),
                c_double(a),
                c_double(b),
                c_double(c),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccDilate returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def symmetry(dimTags, a, b, c, d):
            """
            Applies a symmetry transformation to the geometrical entities `dimTag',
            with respect to the plane of equation `a' * x + `b' * y + `c' * z + `d' =
            0.
            """
            api_dimTags_, api_dimTags_n_ = _ivectorpair(dimTags)
            ierr = c_int()
            lib.gmshModelOccSymmetry(
                api_dimTags_, api_dimTags_n_,
                c_double(a),
                c_double(b),
                c_double(c),
                c_double(d),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccSymmetry returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def copy(dimTags):
            """
            Copies the entities `dimTags'; the new entities are returned in
            `outDimTags'.

            Returns `outDimTags'.
            """
            api_dimTags_, api_dimTags_n_ = _ivectorpair(dimTags)
            api_outDimTags_, api_outDimTags_n_ = POINTER(c_int)(), c_size_t()
            ierr = c_int()
            lib.gmshModelOccCopy(
                api_dimTags_, api_dimTags_n_,
                byref(api_outDimTags_), byref(api_outDimTags_n_),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccCopy returned non-zero error code: ",
                    ierr.value)
            return _ovectorpair(api_outDimTags_, api_outDimTags_n_.value)

        @staticmethod
        def remove(dimTags, recursive=False):
            """
            Removes the entities `dimTags'. If `recursive' is true, removes all the
            entities on their boundaries, down to dimension 0.
            """
            api_dimTags_, api_dimTags_n_ = _ivectorpair(dimTags)
            ierr = c_int()
            lib.gmshModelOccRemove(
                api_dimTags_, api_dimTags_n_,
                c_int(bool(recursive)),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccRemove returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def removeAllDuplicates():
            """
            Removes all duplicate entities (different entities at the same geometrical
            location) after intersecting (using boolean fragments) all highest
            dimensional entities.
            """
            ierr = c_int()
            lib.gmshModelOccRemoveAllDuplicates(
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccRemoveAllDuplicates returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def importShapes(fileName, highestDimOnly=True, format=""):
            """
            Imports BREP, STEP or IGES shapes from the file `fileName'. The imported
            entities are returned in `outDimTags'. If the optional argument
            `highestDimOnly' is set, only import the highest dimensional entities in
            the file. The optional argument `format' can be used to force the format of
            the file (currently "brep", "step" or "iges").

            Returns `outDimTags'.
            """
            api_outDimTags_, api_outDimTags_n_ = POINTER(c_int)(), c_size_t()
            ierr = c_int()
            lib.gmshModelOccImportShapes(
                c_char_p(fileName.encode()),
                byref(api_outDimTags_), byref(api_outDimTags_n_),
                c_int(bool(highestDimOnly)),
                c_char_p(format.encode()),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccImportShapes returned non-zero error code: ",
                    ierr.value)
            return _ovectorpair(api_outDimTags_, api_outDimTags_n_.value)

        @staticmethod
        def setMeshSize(dimTags, size):
            """
            Sets a mesh size constraint on the geometrical entities `dimTags'.
            Currently only entities of dimension 0 (points) are handled.
            """
            api_dimTags_, api_dimTags_n_ = _ivectorpair(dimTags)
            ierr = c_int()
            lib.gmshModelOccSetMeshSize(
                api_dimTags_, api_dimTags_n_,
                c_double(size),
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccSetMeshSize returned non-zero error code: ",
                    ierr.value)

        @staticmethod
        def synchronize():
            """
            Synchronize the internal OpenCASCADE CAD representation with the current
            Gmsh model. This can be called at any time, but since it involves a non
            trivial amount of processing, the number of synchronization points should
            normally be minimized.
            """
            ierr = c_int()
            lib.gmshModelOccSynchronize(
                byref(ierr))
            if ierr.value != 0:
                raise ValueError(
                    "gmshModelOccSynchronize returned non-zero error code: ",
                    ierr.value)


class view:
    """
    Post-processing view functions
    """

    @staticmethod
    def add(name, tag=-1):
        """
        Adds a new post-processing view, with name `name'. If `tag' is positive use
        it (and remove the view with that tag if it already exists), otherwise
        associate a new tag. Returns the view tag.

        Returns an integer.
        """
        ierr = c_int()
        api__result__ = lib.gmshViewAdd(
            c_char_p(name.encode()),
            c_int(tag),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshViewAdd returned non-zero error code: ",
                ierr.value)
        return api__result__

    @staticmethod
    def remove(tag):
        """
        Removes the view with tag `tag'.
        """
        ierr = c_int()
        lib.gmshViewRemove(
            c_int(tag),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshViewRemove returned non-zero error code: ",
                ierr.value)

    @staticmethod
    def getIndex(tag):
        """
        Gets the index of the view with tag `tag' in the list of currently loaded
        views. This dynamic index (it can change when views are removed) is used to
        access view options.

        Returns an integer.
        """
        ierr = c_int()
        api__result__ = lib.gmshViewGetIndex(
            c_int(tag),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshViewGetIndex returned non-zero error code: ",
                ierr.value)
        return api__result__

    @staticmethod
    def getTags():
        """
        Gets the tags of all views.

        Returns `tags'.
        """
        api_tags_, api_tags_n_ = POINTER(c_int)(), c_size_t()
        ierr = c_int()
        lib.gmshViewGetTags(
            byref(api_tags_), byref(api_tags_n_),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshViewGetTags returned non-zero error code: ",
                ierr.value)
        return _ovectorint(api_tags_, api_tags_n_.value)

    @staticmethod
    def addModelData(tag, step, modelName, dataType, tags, data, time=0., numComponents=-1, partition=0):
        """
        Adds model-based post-processing data to the view with tag `tag'.
        `modelName' identifies the model the data is attached to. `dataType'
        specifies the type of data, currently either "NodeData", "ElementData" or
        "ElementNodeData". `step' specifies the identifier (>= 0) of the data in a
        sequence. `tags' gives the tags of the nodes or elements in the mesh to
        which the data is associated. `data' is a vector of the same length as
        `tags': each entry is the vector of double precision numbers representing
        the data associated with the corresponding tag. The optional `time'
        argument associate a time value with the data. `numComponents' gives the
        number of data components (1 for scalar data, 3 for vector data, etc.) per
        entity; if negative, it is automatically inferred (when possible) from the
        input data. `partition' allows to specify data in several sub-sets.
        """
        api_tags_, api_tags_n_ = _ivectorint(tags)
        api_data_, api_data_n_, api_data_nn_ = _ivectorvectordouble(data)
        ierr = c_int()
        lib.gmshViewAddModelData(
            c_int(tag),
            c_int(step),
            c_char_p(modelName.encode()),
            c_char_p(dataType.encode()),
            api_tags_, api_tags_n_,
            api_data_, api_data_n_, api_data_nn_,
            c_double(time),
            c_int(numComponents),
            c_int(partition),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshViewAddModelData returned non-zero error code: ",
                ierr.value)

    @staticmethod
    def getModelData(tag, step):
        """
        Gets model-based post-processing data from the view with tag `tag' at step
        `step'. Returns the `data' associated to the nodes or the elements with
        tags `tags', as well as the `dataType' and the number of components
        `numComponents'.

        Returns `dataType', `tags', `data', `time', `numComponents'.
        """
        api_dataType_ = c_char_p()
        api_tags_, api_tags_n_ = POINTER(c_int)(), c_size_t()
        api_data_, api_data_n_, api_data_nn_ = POINTER(POINTER(c_double))(), POINTER(c_size_t)(), c_size_t()
        api_time_ = c_double()
        api_numComponents_ = c_int()
        ierr = c_int()
        lib.gmshViewGetModelData(
            c_int(tag),
            c_int(step),
            byref(api_dataType_),
            byref(api_tags_), byref(api_tags_n_),
            byref(api_data_), byref(api_data_n_), byref(api_data_nn_),
            byref(api_time_),
            byref(api_numComponents_),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshViewGetModelData returned non-zero error code: ",
                ierr.value)
        return (
            _ostring(api_dataType_),
            _ovectorint(api_tags_, api_tags_n_.value),
            _ovectorvectordouble(api_data_, api_data_n_, api_data_nn_),
            api_time_.value,
            api_numComponents_.value)

    @staticmethod
    def addListData(tag, type, numEle, data):
        """
        Adds list-based post-processing data to the view with tag `tag'. `type'
        identifies the data: "SP" for scalar points, "VP", for vector points, etc.
        `numEle' gives the number of elements in the data. `data' contains the data
        for the `numEle' elements.
        """
        api_data_, api_data_n_ = _ivectordouble(data)
        ierr = c_int()
        lib.gmshViewAddListData(
            c_int(tag),
            c_char_p(type.encode()),
            c_int(numEle),
            api_data_, api_data_n_,
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshViewAddListData returned non-zero error code: ",
                ierr.value)

    @staticmethod
    def getListData(tag):
        """
        Gets list-based post-processing data from the view with tag `tag'. Returns
        the types `dataTypes', the number of elements `numElements' for each data
        type and the `data' for each data type.

        Returns `dataType', `numElements', `data'.
        """
        api_dataType_, api_dataType_n_ = POINTER(POINTER(c_char))(), c_size_t()
        api_numElements_, api_numElements_n_ = POINTER(c_int)(), c_size_t()
        api_data_, api_data_n_, api_data_nn_ = POINTER(POINTER(c_double))(), POINTER(c_size_t)(), c_size_t()
        ierr = c_int()
        lib.gmshViewGetListData(
            c_int(tag),
            byref(api_dataType_), byref(api_dataType_n_),
            byref(api_numElements_), byref(api_numElements_n_),
            byref(api_data_), byref(api_data_n_), byref(api_data_nn_),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshViewGetListData returned non-zero error code: ",
                ierr.value)
        return (
            _ovectorstring(api_dataType_, api_dataType_n_.value),
            _ovectorint(api_numElements_, api_numElements_n_.value),
            _ovectorvectordouble(api_data_, api_data_n_, api_data_nn_))

    @staticmethod
    def probe(tag, x, y, z, step=-1, numComp=-1, gradient=False, tolerance=0., xElemCoord=[], yElemCoord=[], zElemCoord=[]):
        """
        Probes the view `tag' for its `value' at point (`x', `y', `z'). Returns
        only the value at step `step' is `step' is positive. Returns only values
        with `numComp' if `numComp' is positive. Returns the gradient of the
        `value' if `gradient' is set. Probes with a geometrical tolerance (in the
        reference unit cube) of `tolerance' if `tolerance' is not zero. Returns the
        result from the element described by its coordinates if `xElementCoord',
        `yElementCoord' and `zElementCoord' are provided.

        Returns `value'.
        """
        api_value_, api_value_n_ = POINTER(c_double)(), c_size_t()
        api_xElemCoord_, api_xElemCoord_n_ = _ivectordouble(xElemCoord)
        api_yElemCoord_, api_yElemCoord_n_ = _ivectordouble(yElemCoord)
        api_zElemCoord_, api_zElemCoord_n_ = _ivectordouble(zElemCoord)
        ierr = c_int()
        lib.gmshViewProbe(
            c_int(tag),
            c_double(x),
            c_double(y),
            c_double(z),
            byref(api_value_), byref(api_value_n_),
            c_int(step),
            c_int(numComp),
            c_int(bool(gradient)),
            c_double(tolerance),
            api_xElemCoord_, api_xElemCoord_n_,
            api_yElemCoord_, api_yElemCoord_n_,
            api_zElemCoord_, api_zElemCoord_n_,
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshViewProbe returned non-zero error code: ",
                ierr.value)
        return _ovectordouble(api_value_, api_value_n_.value)

    @staticmethod
    def write(tag, fileName, append=False):
        """
        Writes the view to a file `fileName'. The export format is determined by
        the file extension. Appends to the file if `append' is set.
        """
        ierr = c_int()
        lib.gmshViewWrite(
            c_int(tag),
            c_char_p(fileName.encode()),
            c_int(bool(append)),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshViewWrite returned non-zero error code: ",
                ierr.value)


class plugin:
    """
    Plugin functions
    """

    @staticmethod
    def setNumber(name, option, value):
        """
        Sets the numerical option `option' to the value `value' for plugin `name'.
        """
        ierr = c_int()
        lib.gmshPluginSetNumber(
            c_char_p(name.encode()),
            c_char_p(option.encode()),
            c_double(value),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshPluginSetNumber returned non-zero error code: ",
                ierr.value)

    @staticmethod
    def setString(name, option, value):
        """
        Sets the string option `option' to the value `value' for plugin `name'.
        """
        ierr = c_int()
        lib.gmshPluginSetString(
            c_char_p(name.encode()),
            c_char_p(option.encode()),
            c_char_p(value.encode()),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshPluginSetString returned non-zero error code: ",
                ierr.value)

    @staticmethod
    def run(name):
        """
        Runs the plugin `name'.
        """
        ierr = c_int()
        lib.gmshPluginRun(
            c_char_p(name.encode()),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshPluginRun returned non-zero error code: ",
                ierr.value)


class graphics:
    """
    Graphics functions
    """

    @staticmethod
    def draw():
        """
        Draws all the OpenGL scenes.
        """
        ierr = c_int()
        lib.gmshGraphicsDraw(
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshGraphicsDraw returned non-zero error code: ",
                ierr.value)


class fltk:
    """
    Fltk graphical user interface functions
    """

    @staticmethod
    def initialize():
        """
        Creates the Fltk graphical user interface.
        """
        ierr = c_int()
        lib.gmshFltkInitialize(
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshFltkInitialize returned non-zero error code: ",
                ierr.value)

    @staticmethod
    def wait(time=-1.):
        """
        Waits at most `time' seconds for user interface events and returns. If
        `time' < 0, waits indefinitely. First automatically creates the user
        interface if it has not yet been initialized.
        """
        ierr = c_int()
        lib.gmshFltkWait(
            c_double(time),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshFltkWait returned non-zero error code: ",
                ierr.value)

    @staticmethod
    def run():
        """
        Runs the event loop of the Fltk graphical user interface, i.e. repeatedly
        calls `wait'. First automatically creates the user interface if it has not
        yet been initialized.
        """
        ierr = c_int()
        lib.gmshFltkRun(
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshFltkRun returned non-zero error code: ",
                ierr.value)


class onelab:
    """
    ONELAB server functions
    """

    @staticmethod
    def get(format="json"):
        """
        Gets `data' from the ONELAB server.

        Returns `data'.
        """
        api_data_ = c_char_p()
        ierr = c_int()
        lib.gmshOnelabGet(
            byref(api_data_),
            c_char_p(format.encode()),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshOnelabGet returned non-zero error code: ",
                ierr.value)
        return _ostring(api_data_)

    @staticmethod
    def set(data, format="json"):
        """
        Sets `data' in the ONELAB server.
        """
        ierr = c_int()
        lib.gmshOnelabSet(
            c_char_p(data.encode()),
            c_char_p(format.encode()),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshOnelabSet returned non-zero error code: ",
                ierr.value)

    @staticmethod
    def run(name="", command=""):
        """
        Runs a ONELAB client. If `name' is provided, creates a new ONELAB client
        with name `name' and executes `command'. If not, attemps to run a client
        that might be linked to the processed input files.
        """
        ierr = c_int()
        lib.gmshOnelabRun(
            c_char_p(name.encode()),
            c_char_p(command.encode()),
            byref(ierr))
        if ierr.value != 0:
            raise ValueError(
                "gmshOnelabRun returned non-zero error code: ",
                ierr.value)
