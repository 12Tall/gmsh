# Gmsh - Copyright (C) 1997-2018 C. Geuzaine, J.-F. Remacle
#
# See the LICENSE.txt file for license information. Please report all
# bugs and problems to the public mailing list <gmsh@onelab.info>.

# This file defines the Gmsh Julia API.
#
# Do not edit it directly: it is automatically generated by `api/gen.py'.
#
# By design, the Gmsh Julia API is purely functional, and only uses elementary
# types. See `demos/api' for examples.

"""
Top-level functions
"""
module gmsh

const clib = "libgmsh"

"""
Initialize Gmsh. This must be called before any call to the other functions in
the API. If `argc' and `argv' are provided, they will be handled in the same way
as the command line arguments in the Gmsh app. If `readConfigFiles' is set, read
system Gmsh configuration files (gmshrc and gmsh-options).
"""
function initialize(argv = Vector{String}(), readConfigFiles = true)
    ierr = Vector{Cint}(1)
    ccall((:gmshInitialize, clib), Void,
          (Cint, Ptr{Ptr{Cchar}}, Cint, Ptr{Cint}),
          length(argv), argv, readConfigFiles, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Finalize Gmsh. This must be called when you are done using the Gmsh API.
"""
function finalize()
    ierr = Vector{Cint}(1)
    ccall((:gmshFinalize, clib), Void,
          (Ptr{Cint},),
          ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Open a file. Equivalent to the `File->Open' menu in the Gmsh app. Handling of
the file depends on its extension and/or its contents.
"""
function open(fileName)
    ierr = Vector{Cint}(1)
    ccall((:gmshOpen, clib), Void,
          (Ptr{Cchar}, Ptr{Cint}),
          fileName, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Merge a file. Equivalent to the `File->Merge' menu in the Gmsh app. Handling of
the file depends on its extension and/or its contents.
"""
function merge(fileName)
    ierr = Vector{Cint}(1)
    ccall((:gmshMerge, clib), Void,
          (Ptr{Cchar}, Ptr{Cint}),
          fileName, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Write a file. The export format is determined by the file extension.
"""
function write(fileName)
    ierr = Vector{Cint}(1)
    ccall((:gmshWrite, clib), Void,
          (Ptr{Cchar}, Ptr{Cint}),
          fileName, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Clear all loaded models and post-processing data, and add a new empty model.
"""
function clear()
    ierr = Vector{Cint}(1)
    ccall((:gmshClear, clib), Void,
          (Ptr{Cint},),
          ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Global option handling functions
"""
module option

import ..gmsh

"""
Set a numerical option to `value'. `name' is of the form "category.option" or
"category[num].option". Available categories and options are listed in the Gmsh
reference manual.
"""
function setNumber(name, value)
    ierr = Vector{Cint}(1)
    ccall((:gmshOptionSetNumber, gmsh.clib), Void,
          (Ptr{Cchar}, Cdouble, Ptr{Cint}),
          name, value, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Get the `value' of a numerical option.

Return `value'.
"""
function getNumber(name)
    ierr = Vector{Cint}(1)
    ccall((:gmshOptionGetNumber, gmsh.clib), Void,
          (Ptr{Cchar}, Ptr{Cdouble}, Ptr{Cint}),
          name, value, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return value
end

"""
Set a string option to `value'.
"""
function setString(name, value)
    ierr = Vector{Cint}(1)
    ccall((:gmshOptionSetString, gmsh.clib), Void,
          (Ptr{Cchar}, Ptr{Cchar}, Ptr{Cint}),
          name, value, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Get the `value' of a string option.

Return `value'.
"""
function getString(name)
    ierr = Vector{Cint}(1)
    ccall((:gmshOptionGetString, gmsh.clib), Void,
          (Ptr{Cchar}, Ptr{Ptr{Cchar}}, Ptr{Cint}),
          name, value, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return value
end

end # end of module option

"""
Per-model functions
"""
module model

import ..gmsh

"""
Add a new model, with name `name', and set it as the current model.
"""
function add(name)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelAdd, gmsh.clib), Void,
          (Ptr{Cchar}, Ptr{Cint}),
          name, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Remove the current model.
"""
function remove()
    ierr = Vector{Cint}(1)
    ccall((:gmshModelRemove, gmsh.clib), Void,
          (Ptr{Cint},),
          ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
List the names of all models.

Return `names'.
"""
function list()
    ierr = Vector{Cint}(1)
    ccall((:gmshModelList, gmsh.clib), Void,
          (Ptr{Ptr{Cchar}}, Ptr{Csize_t}, Ptr{Cint}),
          names, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return names
end

"""
Set the current model to the model with name `name'. If several models have the
same name, select the one that was added first.
"""
function setCurrent(name)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelSetCurrent, gmsh.clib), Void,
          (Ptr{Cchar}, Ptr{Cint}),
          name, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Get all the (elementary) geometrical entities in the current model. If `dim' is
>= 0, return only the entities of the specified dimension (e.g. points if `dim'
== 0). The entities are returned as a vector of (dim, tag) integer pairs.

Return `dimTags'.
"""
function getEntities(dim = -1)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGetEntities, gmsh.clib), Void,
          (Ptr{Ptr{Cint}}, Ptr{Csize_t}, Cint, Ptr{Cint}),
          dimTags, dim, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return dimTags
end

"""
Get all the physical groups in the current model. If `dim' is >= 0, return only
the entities of the specified dimension (e.g. physical points if `dim' == 0).
The entities are returned as a vector of (dim, tag) integer pairs.

Return `dimTags'.
"""
function getPhysicalGroups(dim = -1)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGetPhysicalGroups, gmsh.clib), Void,
          (Ptr{Ptr{Cint}}, Ptr{Csize_t}, Cint, Ptr{Cint}),
          dimTags, dim, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return dimTags
end

"""
Get the tags of all the (elementary) geometrical entities making up the physical
group of dimension `dim' and tag `tag'.

Return `tags'.
"""
function getEntitiesForPhysicalGroup(dim, tag)
    api_tags_= Vector{Ptr{Cint}}(1)
    api_tags_n_= Vector{Csize_t}(1)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGetEntitiesForPhysicalGroup, gmsh.clib), Void,
          (Cint, Cint, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}),
          dim, tag, api_tags_, api_tags_n_, ierr)
    tags = unsafe_wrap(Array, api_tags_[1], api_tags_n_[1], true)
    if ierr[1] != 0
      println(ierr[1])
    end
    return tags
end

"""
Add a physical group of dimension `dim', grouping the elementary entities with
tags `tags'. Return the tag of the physical group, equal to `tag' if `tag' is
positive, or a new tag if `tag' < 0.

Return an integer.
"""
function addPhysicalGroup(dim, tags, tag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelAddPhysicalGroup, gmsh.clib), Cint,
          (Cint, Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          dim, convert(Vector{Cint}, tags), length(tags), tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Set the name of the physical group of dimension `dim' and tag `tag'.
"""
function setPhysicalName(dim, tag, name)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelSetPhysicalName, gmsh.clib), Void,
          (Cint, Cint, Ptr{Cchar}, Ptr{Cint}),
          dim, tag, name, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Get the name of the physical group of dimension `dim' and tag `tag'.

Return `name'.
"""
function getPhysicalName(dim, tag)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGetPhysicalName, gmsh.clib), Void,
          (Cint, Cint, Ptr{Ptr{Cchar}}, Ptr{Cint}),
          dim, tag, name, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return name
end

"""
Get the boundary of the geometrical entities `dimTags'. Return in `outDimTags'
the boundary of the individual entities (if `combined' is false) or the boundary
of the combined geometrical shape formed by all input entities (if `combined' is
true). Return tags multiplied by the sign of the boundary entity if `oriented'
is true. Apply the boundary operator recursively down to dimension 0 (i.e. to
points) if `recursive' is true.

Return `outDimTags'.
"""
function getBoundary(dimTags, combined = true, oriented = true, recursive = false)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGetBoundary, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Cint, Cint, Cint, Ptr{Cint}),
          dimTags, outDimTags, combined, oriented, recursive, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return outDimTags
end

"""
Get the (elementary) geometrical entities in the bounding box defined by the two
points (`xmin', `ymin', `zmin') and (`xmax', `ymax', `zmax'). If `dim' is >= 0,
return only the entities of the specified dimension (e.g. points if `dim' == 0).

Return `tags'.
"""
function getEntitiesInBoundingBox(xmin, ymin, zmin, xmax, ymax, zmax, dim = -1)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGetEntitiesInBoundingBox, gmsh.clib), Void,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Cint, Ptr{Cint}),
          xmin, ymin, zmin, xmax, ymax, zmax, tags, dim, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return tags
end

"""
Get the bounding box (`xmin', `ymin', `zmin'), (`xmax', `ymax', `zmax') of the
geometrical entity of dimension `dim' and tag `tag'.

Return `xmin', `ymin', `zmin', `xmax', `ymax', `zmax'.
"""
function getBoundingBox(dim, tag)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGetBoundingBox, gmsh.clib), Void,
          (Cint, Cint, Ptr{Cdouble}, Ptr{Cdouble}, Ptr{Cdouble}, Ptr{Cdouble}, Ptr{Cdouble}, Ptr{Cdouble}, Ptr{Cint}),
          dim, tag, xmin, ymin, zmin, xmax, ymax, zmax, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return xmin, ymin, zmin, xmax, ymax, zmax
end

"""
Add a discrete geometrical entity (defined by a mesh) of dimension `dim' in the
current model. Return the tag of the new discrete entity, equal to `tag' if
`tag' is positive, or a new tag if `tag' < 0. `boundary' specifies the tags of
the entities on the boundary of the discrete entity, if any. Specyfing
`boundary' allows Gmsh to construct the topology of the overall model.

Return an integer.
"""
function addDiscreteEntity(dim, tag = -1, boundary = std::vector<int>())
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelAddDiscreteEntity, gmsh.clib), Cint,
          (Cint, Cint, Ptr{Cint}, Csize_t, Ptr{Cint}),
          dim, tag, convert(Vector{Cint}, boundary), length(boundary), ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Remove the entities `dimTags' of the current model. If `recursive' is true,
remove all the entities on their boundaries, down to dimension 0.
"""
function removeEntities(dimTags, recursive = false)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelRemoveEntities, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          dimTags, recursive, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Get the type of the entity of dimension `dim' and tag `tag'.

Return `entityType'.
"""
function getType(dim, tag)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGetType, gmsh.clib), Void,
          (Cint, Cint, Ptr{Ptr{Cchar}}, Ptr{Cint}),
          dim, tag, entityType, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return entityType
end

"""
Per-model meshing functions
"""
module mesh

import ...gmsh

"""
Generate a mesh of the current model, up to dimension `dim' (0, 1, 2 or 3).
"""
function generate(dim = 3)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshGenerate, gmsh.clib), Void,
          (Cint, Ptr{Cint}),
          dim, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Compute a basis representation for homology spaces after a mesh has been
generated. The computation domain is given in a list of physical group tags
`domainTags'; if empty, the whole mesh is the domain. The computation subdomain
for relative homology computation is given in a list of physical group tags
`subdomainTags'; if empty, absolute homology is computed. The dimensions
homology bases to be computed are given in the list `dim'; if empty, all bases
are computed. Resulting basis representation chains are stored as physical
groups in the mesh.
"""
function homology(domainTags = std::vector<int>(), subdomainTags = std::vector<int>(), dims = std::vector<int>())
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshHomology, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Ptr{Cint}, Csize_t, Ptr{Cint}, Csize_t, Ptr{Cint}),
          convert(Vector{Cint}, domainTags), length(domainTags), convert(Vector{Cint}, subdomainTags), length(subdomainTags), convert(Vector{Cint}, dims), length(dims), ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Compute a basis representation for cohomology spaces after a mesh has been
generated. The computation domain is given in a list of physical group tags
`domainTags'; if empty, the whole mesh is the domain. The computation subdomain
for relative cohomology computation is given in a list of physical group tags
`subdomainTags'; if empty, absolute cohomology is computed. The dimensions
homology bases to be computed are given in the list `dim'; if empty, all bases
are computed. Resulting basis representation cochains are stored as physical
groups in the mesh.
"""
function cohomology(domainTags = std::vector<int>(), subdomainTags = std::vector<int>(), dims = std::vector<int>())
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshCohomology, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Ptr{Cint}, Csize_t, Ptr{Cint}, Csize_t, Ptr{Cint}),
          convert(Vector{Cint}, domainTags), length(domainTags), convert(Vector{Cint}, subdomainTags), length(subdomainTags), convert(Vector{Cint}, dims), length(dims), ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Partition the mesh of the current model into `numPart' partitions.
"""
function partition(numPart)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshPartition, gmsh.clib), Void,
          (Cint, Ptr{Cint}),
          numPart, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Refine the mesh of the current model by uniformly splitting the elements.
"""
function refine()
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshRefine, gmsh.clib), Void,
          (Ptr{Cint},),
          ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Set the order of the elements in the mesh of the current model to `order'.
"""
function setOrder(order)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshSetOrder, gmsh.clib), Void,
          (Cint, Ptr{Cint}),
          order, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Remove duplicate mesh nodes in the mesh of the current model.
"""
function removeDuplicateNodes()
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshRemoveDuplicateNodes, gmsh.clib), Void,
          (Ptr{Cint},),
          ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Get the last entities (if any) where a meshing error occurred. Currently only
populated by the new 3D meshing algorithms.

Return `dimTags'.
"""
function getLastEntityError()
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshGetLastEntityError, gmsh.clib), Void,
          (Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}),
          dimTags, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return dimTags
end

"""
Get the last mesh nodes (if any) where a meshing error occurred. Currently only
populated by the new 3D meshing algorithms.

Return `nodeTags'.
"""
function getLastNodeError()
    api_nodeTags_= Vector{Ptr{Cint}}(1)
    api_nodeTags_n_= Vector{Csize_t}(1)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshGetLastNodeError, gmsh.clib), Void,
          (Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}),
          api_nodeTags_, api_nodeTags_n_, ierr)
    nodeTags = unsafe_wrap(Array, api_nodeTags_[1], api_nodeTags_n_[1], true)
    if ierr[1] != 0
      println(ierr[1])
    end
    return nodeTags
end

"""
Get the mesh nodes of the entity of dimension `dim' and `tag' tag. If `tag' < 0,
get the nodes for all entities of dimension `dim'. If `dim' and `tag' are
negative, get all the nodes in the mesh. `nodeTags' contains the node tags
(their unique, strictly positive identification numbers). `coord' is a vector of
length 3 times the length of `nodeTags' that contains the (x, y, z) coordinates
of the nodes, concatenated. If `dim' >= 0, `parametricCoord' contains the
parametric coordinates of the nodes, if available. The length of
`parametricCoord' can be 0 or `dim' times the length of `nodeTags'.

Return `nodeTags', `coord', `parametricCoord'.
"""
function getNodes(dim = -1, tag = -1)
    api_nodeTags_= Vector{Ptr{Cint}}(1)
    api_nodeTags_n_= Vector{Csize_t}(1)
    api_coord_= Vector{Ptr{Cdouble}}(1)
    api_coord_n_= Vector{Csize_t}(1)
    api_parametricCoord_= Vector{Ptr{Cdouble}}(1)
    api_parametricCoord_n_= Vector{Csize_t}(1)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshGetNodes, gmsh.clib), Void,
          (Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Cint, Cint, Ptr{Cint}),
          api_nodeTags_, api_nodeTags_n_, api_coord_, api_coord_n_, api_parametricCoord_, api_parametricCoord_n_, dim, tag, ierr)
    nodeTags = unsafe_wrap(Array, api_nodeTags_[1], api_nodeTags_n_[1], true)
    coord = unsafe_wrap(Array, api_coord_[1], api_coord_n_[1], true)
    parametricCoord = unsafe_wrap(Array, api_parametricCoord_[1], api_parametricCoord_n_[1], true)
    if ierr[1] != 0
      println(ierr[1])
    end
    return nodeTags, coord, parametricCoord
end

"""
Get the mesh elements of the entity of dimension `dim' and `tag' tag. If `tag' <
0, get the elements for all entities of dimension `dim'. If `dim' and `tag' are
negative, get all the elements in the mesh. `elementTypes' contains the MSH
types of the elements (e.g. `2' for 3-node triangles: see `getElementProperties'
to obtain the properties for a given element type). `elementTags' is a vector of
the same length as `elementTypes'; each entry is a vector containing the tags
(unique, strictly positive identifiers) of the elements of the corresponding
type. `nodeTags' is also a vector of the same length as `elementTypes'; each
entry is a vector of length equal to the number of elements of the given type
times the number of nodes for this type of element, that contains the node tags
of all the elements of the given type, concatenated.

Return `elementTypes', `elementTags', `nodeTags'.
"""
function getElements(dim = -1, tag = -1)
    api_elementTypes_= Vector{Ptr{Cint}}(1)
    api_elementTypes_n_= Vector{Csize_t}(1)
    api_elementTags_= Vector{Ptr{Ptr{Cint}}}(1)
    api_elementTags_n_= Vector{Ptr{Csize_t}}(1)
    api_elementTags_nn_= Vector{Csize_t}(1)
    api_nodeTags_= Vector{Ptr{Ptr{Cint}}}(1)
    api_nodeTags_n_= Vector{Ptr{Csize_t}}(1)
    api_nodeTags_nn_= Vector{Csize_t}(1)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshGetElements, gmsh.clib), Void,
          (Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Ptr{Ptr{Cint}}}, Ptr{Ptr{Csize_t}}, Ptr{Csize_t}, Ptr{Ptr{Ptr{Cint}}}, Ptr{Ptr{Csize_t}}, Ptr{Csize_t}, Cint, Cint, Ptr{Cint}),
          api_elementTypes_, api_elementTypes_n_, api_elementTags_, api_elementTags_n_, api_elementTags_nn_, api_nodeTags_, api_nodeTags_n_, api_nodeTags_nn_, dim, tag, ierr)
    elementTypes = unsafe_wrap(Array, api_elementTypes_[1], api_elementTypes_n_[1], true)
    tmp_api_elementTags_= unsafe_wrap(Array, api_elementTags_[1], api_elementTags_nn_[1], true)
    tmp_api_elementTags_n_= unsafe_wrap(Array, api_elementTags_n_[1], api_elementTags_nn_[1], true)
    elementTags = [ unsafe_wrap(Array, tmp_api_elementTags_[i], tmp_api_elementTags_n_[i], true) for i in 1:api_elementTags_nn_[1] ]
    tmp_api_nodeTags_= unsafe_wrap(Array, api_nodeTags_[1], api_nodeTags_nn_[1], true)
    tmp_api_nodeTags_n_= unsafe_wrap(Array, api_nodeTags_n_[1], api_nodeTags_nn_[1], true)
    nodeTags = [ unsafe_wrap(Array, tmp_api_nodeTags_[i], tmp_api_nodeTags_n_[i], true) for i in 1:api_nodeTags_nn_[1] ]
    if ierr[1] != 0
      println(ierr[1])
    end
    return elementTypes, elementTags, nodeTags
end

"""
Get the properties of an element of type `elementType': its name
(`elementName'), dimension (`dim'), order (`order'), number of nodes
(`numNodes') and parametric coordinates of nodes (`parametricCoord' vector, of
length `dim' times `numNodes').

Return `elementName', `dim', `order', `numNodes', `parametricCoord'.
"""
function getElementProperties(elementType)
    api_parametricCoord_= Vector{Ptr{Cdouble}}(1)
    api_parametricCoord_n_= Vector{Csize_t}(1)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshGetElementProperties, gmsh.clib), Void,
          (Cint, Ptr{Ptr{Cchar}}, Ptr{Cint}, Ptr{Cint}, Ptr{Cint}, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Ptr{Cint}),
          elementType, elementName, dim, order, numNodes, api_parametricCoord_, api_parametricCoord_n_, ierr)
    parametricCoord = unsafe_wrap(Array, api_parametricCoord_[1], api_parametricCoord_n_[1], true)
    if ierr[1] != 0
      println(ierr[1])
    end
    return elementName, dim, order, numNodes, parametricCoord
end

"""
Get the integration data for mesh elements of the entity of dimension `dim' and
`tag' tag. The data is returned by element type and by element, in the same
order as the data returned by `getElements'. `integrationType' specifies the
type of integration (e.g. "Gauss4") and `functionSpaceType' specifies the
function space (e.g. "IsoParametric"). `integrationPoints' contains for each
element type a vector (of length 4 times the number of integration points)
containing the parametric coordinates (u, v, w) and the weight associated to the
integration points. `integrationData' contains for each element type a vector
(of size 13 times the number of integration points) containing the (x, y, z)
coordinates of the integration point, the determinant of the Jacobian and the 9
entries (by row) of the 3x3 Jacobian matrix. If `functionSpaceType' is provided,
`functionSpaceNumComponents' return the number of components returned by the
evaluation of a basis function in the space and `functionSpaceData' contains for
each element type the evaluation of the basis functions at the integration
points.

Return `integrationPoints', `integrationData', `functionSpaceNumComponents', `functionSpaceData'.
"""
function getIntegrationData(integrationType, functionSpaceType, dim = -1, tag = -1)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshGetIntegrationData, gmsh.clib), Void,
          (Ptr{Cchar}, Ptr{Cchar}, Ptr{Ptr{Ptr{Cdouble}}}, Ptr{Ptr{Csize_t}}, Ptr{Csize_t}, Ptr{Ptr{Ptr{Cdouble}}}, Ptr{Ptr{Csize_t}}, Ptr{Csize_t}, Ptr{Cint}, Ptr{Ptr{Ptr{Cdouble}}}, Ptr{Ptr{Csize_t}}, Ptr{Csize_t}, Cint, Cint, Ptr{Cint}),
          integrationType, functionSpaceType, integrationPoints, integrationData, functionSpaceNumComponents, functionSpaceData, dim, tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return integrationPoints, integrationData, functionSpaceNumComponents, functionSpaceData
end

"""
Get the types of mesh elements in the entity of dimension `dim' and `tag' tag.
If `tag' < 0, get the types for all entities of dimension `dim'. If `dim' and
`tag' are negative, get all the types in the mesh.

Return `elementTypes'.
"""
function getElementTypes(dim = -1, tag = -1)
    api_elementTypes_= Vector{Ptr{Cint}}(1)
    api_elementTypes_n_= Vector{Csize_t}(1)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshGetElementTypes, gmsh.clib), Void,
          (Ptr{Ptr{Cint}}, Ptr{Csize_t}, Cint, Cint, Ptr{Cint}),
          api_elementTypes_, api_elementTypes_n_, dim, tag, ierr)
    elementTypes = unsafe_wrap(Array, api_elementTypes_[1], api_elementTypes_n_[1], true)
    if ierr[1] != 0
      println(ierr[1])
    end
    return elementTypes
end

"""
Get the mesh elements in the same way as `getElements', but for a single
`elementType'.

Return `elementTags', `nodeTags'.
"""
function getElementsByType(elementType, dim = -1, tag = -1)
    api_elementTags_= Vector{Ptr{Cint}}(1)
    api_elementTags_n_= Vector{Csize_t}(1)
    api_nodeTags_= Vector{Ptr{Cint}}(1)
    api_nodeTags_n_= Vector{Csize_t}(1)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshGetElementsByType, gmsh.clib), Void,
          (Cint, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Cint, Cint, Ptr{Cint}),
          elementType, api_elementTags_, api_elementTags_n_, api_nodeTags_, api_nodeTags_n_, dim, tag, ierr)
    elementTags = unsafe_wrap(Array, api_elementTags_[1], api_elementTags_n_[1], true)
    nodeTags = unsafe_wrap(Array, api_nodeTags_[1], api_nodeTags_n_[1], true)
    if ierr[1] != 0
      println(ierr[1])
    end
    return elementTags, nodeTags
end

"""
Get the integration data for mesh elements in the same way as
`getIntegrationData', but for a single `elementType'.

Return `integrationPoints', `integrationData', `functionSpaceNumComponents', `functionSpaceData'.
"""
function getIntegrationDataByType(elementType, integrationType, functionSpaceType, dim = -1, tag = -1)
    api_integrationPoints_= Vector{Ptr{Cdouble}}(1)
    api_integrationPoints_n_= Vector{Csize_t}(1)
    api_integrationData_= Vector{Ptr{Cdouble}}(1)
    api_integrationData_n_= Vector{Csize_t}(1)
    api_functionSpaceData_= Vector{Ptr{Cdouble}}(1)
    api_functionSpaceData_n_= Vector{Csize_t}(1)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshGetIntegrationDataByType, gmsh.clib), Void,
          (Cint, Ptr{Cchar}, Ptr{Cchar}, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Ptr{Cint}, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Cint, Cint, Ptr{Cint}),
          elementType, integrationType, functionSpaceType, api_integrationPoints_, api_integrationPoints_n_, api_integrationData_, api_integrationData_n_, functionSpaceNumComponents, api_functionSpaceData_, api_functionSpaceData_n_, dim, tag, ierr)
    integrationPoints = unsafe_wrap(Array, api_integrationPoints_[1], api_integrationPoints_n_[1], true)
    integrationData = unsafe_wrap(Array, api_integrationData_[1], api_integrationData_n_[1], true)
    functionSpaceData = unsafe_wrap(Array, api_functionSpaceData_[1], api_functionSpaceData_n_[1], true)
    if ierr[1] != 0
      println(ierr[1])
    end
    return integrationPoints, integrationData, functionSpaceNumComponents, functionSpaceData
end

"""
Set the mesh nodes in the geometrical entity of dimension `dim' and tag `tag'.
`nodetags' contains the node tags (their unique, strictly positive
identification numbers). `coord' is a vector of length 3 times the length of
`nodeTags' that contains the (x, y, z) coordinates of the nodes, concatenated.
The optional `parametricCoord' vector contains the parametric coordinates of the
nodes, if any. The length of `parametricCoord' can be 0 or `dim' times the
length of `nodeTags'.
"""
function setNodes(dim, tag, nodeTags, coord, parametricCoord = std::vector<double>())
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshSetNodes, gmsh.clib), Void,
          (Cint, Cint, Ptr{Cint}, Csize_t, Ptr{Cdouble}, Csize_t, Ptr{Cdouble}, Csize_t, Ptr{Cint}),
          dim, tag, convert(Vector{Cint}, nodeTags), length(nodeTags), coord, length(coord), parametricCoord, length(parametricCoord), ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Set the mesh elements of the entity of dimension `dim' and `tag' tag. `types'
contains the MSH types of the elements (e.g. `2' for 3-node triangles: see the
Gmsh reference manual). `elementTags' is a vector of the same length as `types';
each entry is a vector containing the tags (unique, strictly positive
identifiers) of the elements of the corresponding type. `nodeTags' is also a
vector of the same length as `types'; each entry is a vector of length equal to
the number of elements of the give type times the number of nodes per element,
that contains the node tags of all the elements of the given type, concatenated.
"""
function setElements(dim, tag, elementTypes, elementTags, nodeTags)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshSetElements, gmsh.clib), Void,
          (Cint, Cint, Ptr{Cint}, Csize_t, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Csize_t, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Csize_t, Ptr{Cint}),
          dim, tag, convert(Vector{Cint}, elementTypes), length(elementTypes), elementTags, nodeTags, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Redistribute all mesh nodes on their associated geometrical entity, based on the
mesh elements. Can be used when importing mesh nodes in bulk (e.g. by
associating them all to a single volume), to reclassify them correctly on model
surfaces, curves, etc.
"""
function reclassifyNodes()
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshReclassifyNodes, gmsh.clib), Void,
          (Ptr{Cint},),
          ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Get the coordinates and the parametric coordinates (if any) of the mesh node
with tag `tag'. This is a useful by inefficient way of accessing mesh node data,
as it relies on a cache stored in the model. For large meshes all the nodes in
the model should be numbered in a continuous sequence of tags from 1 to N to
maintain reasonnable performance (in this case the internal cache is based on a
vector; otherwise it uses a map).

Return `coord', `parametricCoord'.
"""
function getNode(nodeTag)
    api_coord_= Vector{Ptr{Cdouble}}(1)
    api_coord_n_= Vector{Csize_t}(1)
    api_parametricCoord_= Vector{Ptr{Cdouble}}(1)
    api_parametricCoord_n_= Vector{Csize_t}(1)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshGetNode, gmsh.clib), Void,
          (Cint, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Ptr{Cint}),
          nodeTag, api_coord_, api_coord_n_, api_parametricCoord_, api_parametricCoord_n_, ierr)
    coord = unsafe_wrap(Array, api_coord_[1], api_coord_n_[1], true)
    parametricCoord = unsafe_wrap(Array, api_parametricCoord_[1], api_parametricCoord_n_[1], true)
    if ierr[1] != 0
      println(ierr[1])
    end
    return coord, parametricCoord
end

"""
Get the type and node tags of the mesh element with tag `tag'. This is a useful
but inefficient way of accessing mesh element data, as it relies on a cache
stored in the model. For large meshes all the elements in the model should be
numbered in a continuous sequence of tags from 1 to N to maintain reasonnable
performance (in this case the internal cache is based on a vector; otherwise it
uses a map).

Return `elementType', `nodeTags'.
"""
function getElement(elementTag)
    api_nodeTags_= Vector{Ptr{Cint}}(1)
    api_nodeTags_n_= Vector{Csize_t}(1)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshGetElement, gmsh.clib), Void,
          (Cint, Ptr{Cint}, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}),
          elementTag, elementType, api_nodeTags_, api_nodeTags_n_, ierr)
    nodeTags = unsafe_wrap(Array, api_nodeTags_[1], api_nodeTags_n_[1], true)
    if ierr[1] != 0
      println(ierr[1])
    end
    return elementType, nodeTags
end

"""
Set a mesh size constraint on the geometrical entities `dimTags'. Currently only
entities of dimension 0 (points) are handled.
"""
function setSize(dimTags, size)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshSetSize, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Ptr{Cint}),
          dimTags, size, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Set a transfinite meshing constraint on the curve `tag', with `numNodes' mesh
nodes distributed according to `meshType' and `coef'. Currently supported types
are "Progression" (geometrical progression with power `coef') and "Bump"
(refinement toward both extremities of the curve).
"""
function setTransfiniteCurve(tag, numNodes, meshType = "Progression", coef = 1.)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshSetTransfiniteCurve, gmsh.clib), Void,
          (Cint, Cint, Ptr{Cchar}, Cdouble, Ptr{Cint}),
          tag, numNodes, meshType, coef, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Set a transfinite meshing constraint on the surface `tag'. `arrangement'
describes the arrangement of the triangles when the surface is not flagged as
recombined: currently supported values are "Left", "Right", "AlternateLeft" and
"AlternateRight". `cornerTags' can be used to specify the (3 or 4) corners of
the transfinite interpolation explicitly; specifying the corners explicitly is
mandatory if the surface has more that 3 or 4 points on its boundary.
"""
function setTransfiniteSurface(tag, arrangement = "Left", cornerTags = std::vector<int>())
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshSetTransfiniteSurface, gmsh.clib), Void,
          (Cint, Ptr{Cchar}, Ptr{Cint}, Csize_t, Ptr{Cint}),
          tag, arrangement, convert(Vector{Cint}, cornerTags), length(cornerTags), ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Set a transfinite meshing constraint on the surface `tag'. `cornerTags' can be
used to specify the (6 or 8) corners of the transfinite interpolation
explicitly.
"""
function setTransfiniteVolume(tag, cornerTags = std::vector<int>())
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshSetTransfiniteVolume, gmsh.clib), Void,
          (Cint, Ptr{Cint}, Csize_t, Ptr{Cint}),
          tag, convert(Vector{Cint}, cornerTags), length(cornerTags), ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Set a recombination meshing constraint on the geometrical entity of dimension
`dim' and tag `tag'. Currently only entities of dimension 2 (to recombine
triangles into quadrangles) are supported.
"""
function setRecombine(dim, tag)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshSetRecombine, gmsh.clib), Void,
          (Cint, Cint, Ptr{Cint}),
          dim, tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Set a smoothing meshing constraint on the geometrical entity of dimension `dim'
and tag `tag'. `val' iterations of a Laplace smoother are applied.
"""
function setSmoothing(dim, tag, val)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshSetSmoothing, gmsh.clib), Void,
          (Cint, Cint, Cint, Ptr{Cint}),
          dim, tag, val, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Set a reverse meshing constraint on the geometrical entity of dimension `dim'
and tag `tag'. If `val' is true, the mesh orientation will be reversed with
respect to the natural mesh orientation (i.e. the orientation consistent with
the orientation of the geometrical entity). If `val' is false, the mesh is left
as-is.
"""
function setReverse(dim, tag, val = true)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshSetReverse, gmsh.clib), Void,
          (Cint, Cint, Cint, Ptr{Cint}),
          dim, tag, val, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Embed the geometrical entities of dimension `dim' and tags `tags' in the (inDim,
inTag) geometrical entity. `inDim' must be strictly greater than `dim'.
"""
function embed(dim, tags, inDim, inTag)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshEmbed, gmsh.clib), Void,
          (Cint, Ptr{Cint}, Csize_t, Cint, Cint, Ptr{Cint}),
          dim, convert(Vector{Cint}, tags), length(tags), inDim, inTag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Set the meshes of the entities of dimension `dim' and tag `tags' as periodic
copies of the meshes of entities `tagsSource', using the affine transformation
specified in `affineTransformation' (16 entries of a 4x4 matrix, by row).
Currently only available for `dim' == 1 and `dim' == 2.
"""
function setPeriodic(dim, tags, tagsSource, affineTransformation)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshSetPeriodic, gmsh.clib), Void,
          (Cint, Ptr{Cint}, Csize_t, Ptr{Cint}, Csize_t, Ptr{Cdouble}, Csize_t, Ptr{Cint}),
          dim, convert(Vector{Cint}, tags), length(tags), convert(Vector{Cint}, tagsSource), length(tagsSource), affineTransformation, length(affineTransformation), ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Per-model mesh size field functions
"""
module field

import ....gmsh

"""
Add a new mesh size field of type `fieldType'. If `tag' is positive, assign the
tag explcitly; otherwise a new tag is assigned automatically. Return the field
tag.

Return an integer.
"""
function add(fieldType, tag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelMeshFieldAdd, gmsh.clib), Cint,
          (Ptr{Cchar}, Cint, Ptr{Cint}),
          fieldType, tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Remove the field with tag `tag'.
"""
function remove(tag)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshFieldRemove, gmsh.clib), Void,
          (Cint, Ptr{Cint}),
          tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Set the numerical option `option' to value `value' for field `tag'.
"""
function setNumber(tag, option, value)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshFieldSetNumber, gmsh.clib), Void,
          (Cint, Ptr{Cchar}, Cdouble, Ptr{Cint}),
          tag, option, value, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Set the string option `option' to value `value' for field `tag'.
"""
function setString(tag, option, value)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshFieldSetString, gmsh.clib), Void,
          (Cint, Ptr{Cchar}, Ptr{Cchar}, Ptr{Cint}),
          tag, option, value, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Set the numerical list option `option' to value `value' for field `tag'.
"""
function setNumbers(tag, option, value)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshFieldSetNumbers, gmsh.clib), Void,
          (Cint, Ptr{Cchar}, Ptr{Cdouble}, Csize_t, Ptr{Cint}),
          tag, option, value, length(value), ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Set the field `tag' as the background mesh size field.
"""
function setAsBackgroundMesh(tag)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshFieldSetAsBackgroundMesh, gmsh.clib), Void,
          (Cint, Ptr{Cint}),
          tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Set the field `tag' as a boundary layer size field.
"""
function setAsBoundaryLayer(tag)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelMeshFieldSetAsBoundaryLayer, gmsh.clib), Void,
          (Cint, Ptr{Cint}),
          tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

end # end of module field

end # end of module mesh

"""
Internal per-model GEO CAD kernel functions
"""
module geo

import ...gmsh

"""
Add a geometrical point in the internal GEO CAD representation, at coordinates
(x, y, z). If `meshSize' is > 0, add a meshing constraint at that point. If
`tag' is positive, set the tag explicitly; otherwise a new tag is selected
automatically. Return the tag of the point. (Note that the point will be added
in the current model only after `synchronize' is called. This behavior holds for
all the entities added in the geo module.)

Return an integer.
"""
function addPoint(x, y, z, meshSize = 0., tag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelGeoAddPoint, gmsh.clib), Cint,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cint, Ptr{Cint}),
          x, y, z, meshSize, tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a straight line segment between the two points with tags `startTag' and
`endTag'. If `tag' is positive, set the tag explicitly; otherwise a new tag is
selected automatically. Return the tag of the line.

Return an integer.
"""
function addLine(startTag, endTag, tag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelGeoAddLine, gmsh.clib), Cint,
          (Cint, Cint, Cint, Ptr{Cint}),
          startTag, endTag, tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a circle arc (stricly smaller than Pi) between the two points with tags
`startTag' and `endTag', with center `centertag'. If `tag' is positive, set the
tag explicitly; otherwise a new tag is selected automatically. If (`nx', `ny',
`nz') != (0,0,0), explicitely set the plane of the circle arc. Return the tag of
the circle arc.

Return an integer.
"""
function addCircleArc(startTag, centerTag, endTag, tag = -1, nx = 0., ny = 0., nz = 0.)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelGeoAddCircleArc, gmsh.clib), Cint,
          (Cint, Cint, Cint, Cint, Cdouble, Cdouble, Cdouble, Ptr{Cint}),
          startTag, centerTag, endTag, tag, nx, ny, nz, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add an ellipse arc (stricly smaller than Pi) between the two points `startTag'
and `endTag', with center `centertag' and major axis point `majorTag'. If `tag'
is positive, set the tag explicitly; otherwise a new tag is selected
automatically. If (`nx', `ny', `nz') != (0,0,0), explicitely set the plane of
the circle arc. Return the tag of the ellipse arc.

Return an integer.
"""
function addEllipseArc(startTag, centerTag, majorTag, endTag, tag = -1, nx = 0., ny = 0., nz = 0.)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelGeoAddEllipseArc, gmsh.clib), Cint,
          (Cint, Cint, Cint, Cint, Cint, Cdouble, Cdouble, Cdouble, Ptr{Cint}),
          startTag, centerTag, majorTag, endTag, tag, nx, ny, nz, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a spline (Catmull-Rom) curve going through the points `pointTags'. If `tag'
is positive, set the tag explicitly; otherwise a new tag is selected
automatically. Create a periodic curve if the first and last points are the
same. Return the tag of the spline curve.

Return an integer.
"""
function addSpline(pointTags, tag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelGeoAddSpline, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, pointTags), length(pointTags), tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Adds a cubic b-spline curve with `pointTags' control points. If `tag' is
positive, sets the tag explicitly; otherwise a new tag is selected
automatically. Creates a periodic curve if the first and last points are the
same. Return the tag of the b-spline curve.

Return an integer.
"""
function addBSpline(pointTags, tag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelGeoAddBSpline, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, pointTags), length(pointTags), tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a Bezier curve with `pointTags' control points. If `tag' is positive, set
the tag explicitly; otherwise a new tag is selected automatically.  Return the
tag of the Bezier curve.

Return an integer.
"""
function addBezier(pointTags, tag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelGeoAddBezier, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, pointTags), length(pointTags), tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a curve loop (a closed wire) formed by the curves `curveTags'. `curveTags'
should contain (signed) tags of geometrical enties of dimension 1 forming a
closed loop: a negative tag signifies that the underlying curve is considered
with reversed orientation. If `tag' is positive, set the tag explicitly;
otherwise a new tag is selected automatically. Return the tag of the curve loop.

Return an integer.
"""
function addCurveLoop(curveTags, tag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelGeoAddCurveLoop, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, curveTags), length(curveTags), tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a plane surface defined by one or more curve loops `wireTags'. The first
curve loop defines the exterior contour; additional curve loop define holes. If
`tag' is positive, set the tag explicitly; otherwise a new tag is selected
automatically. Return the tag of the surface.

Return an integer.
"""
function addPlaneSurface(wireTags, tag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelGeoAddPlaneSurface, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, wireTags), length(wireTags), tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a surface filling the curve loops in `wireTags'. Currently only a single
curve loop is supported; this curve loop should be composed by 3 or 4 curves
only. If `tag' is positive, set the tag explicitly; otherwise a new tag is
selected automatically. Return the tag of the surface.

Return an integer.
"""
function addSurfaceFilling(wireTags, tag = -1, sphereCenterTag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelGeoAddSurfaceFilling, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Cint, Ptr{Cint}),
          convert(Vector{Cint}, wireTags), length(wireTags), tag, sphereCenterTag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a surface loop (a closed shell) formed by `surfaceTags'.  If `tag' is
positive, set the tag explicitly; otherwise a new tag is selected automatically.
Return the tag of the shell.

Return an integer.
"""
function addSurfaceLoop(surfaceTags, tag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelGeoAddSurfaceLoop, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, surfaceTags), length(surfaceTags), tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a volume (a region) defined by one or more shells `shellTags'. The first
surface loop defines the exterior boundary; additional surface loop define
holes. If `tag' is positive, set the tag explicitly; otherwise a new tag is
selected automatically. Return the tag of the volume.

Return an integer.
"""
function addVolume(shellTags, tag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelGeoAddVolume, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, shellTags), length(shellTags), tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Extrude the geometrical entities `dimTags' by translation along (`dx', `dy',
`dz'). Return extruded entities in `outDimTags'. If `numElements' is not empty,
also extrude the mesh: the entries in `numElements' give the number of elements
in each layer. If `height' is not empty, it provides the (cummulative) height of
the different layers, normalized to 1.

Return `outDimTags'.
"""
function extrude(dimTags, dx, dy, dz, numElements = std::vector<int>(), heights = std::vector<double>(), recombine = false)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGeoExtrude, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}, Csize_t, Ptr{Cdouble}, Csize_t, Cint, Ptr{Cint}),
          dimTags, dx, dy, dz, outDimTags, convert(Vector{Cint}, numElements), length(numElements), heights, length(heights), recombine, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return outDimTags
end

"""
Extrude the geometrical entities `dimTags' by rotation of `angle' radians around
the axis of revolution defined by the point (`x', `y', `z') and the direction
(`ax', `ay', `az'). Return extruded entities in `outDimTags'. If `numElements'
is not empty, also extrude the mesh: the entries in `numElements' give the
number of elements in each layer. If `height' is not empty, it provides the
(cummulative) height of the different layers, normalized to 1.

Return `outDimTags'.
"""
function revolve(dimTags, x, y, z, ax, ay, az, angle, numElements = std::vector<int>(), heights = std::vector<double>(), recombine = false)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGeoRevolve, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}, Csize_t, Ptr{Cdouble}, Csize_t, Cint, Ptr{Cint}),
          dimTags, x, y, z, ax, ay, az, angle, outDimTags, convert(Vector{Cint}, numElements), length(numElements), heights, length(heights), recombine, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return outDimTags
end

"""
Extrude the geometrical entities `dimTags' by a combined translation and
rotation of `angle' radians, along (`dx', `dy', `dz') and around the axis of
revolution defined by the point (`x', `y', `z') and the direction (`ax', `ay',
`az'). Return extruded entities in `outDimTags'. If `numElements' is not empty,
also extrude the mesh: the entries in `numElements' give the number of elements
in each layer. If `height' is not empty, it provides the (cummulative) height of
the different layers, normalized to 1.

Return `outDimTags'.
"""
function twist(dimTags, x, y, z, dx, dy, dz, ax, ay, az, angle, numElements = std::vector<int>(), heights = std::vector<double>(), recombine = false)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGeoTwist, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}, Csize_t, Ptr{Cdouble}, Csize_t, Cint, Ptr{Cint}),
          dimTags, x, y, z, dx, dy, dz, ax, ay, az, angle, outDimTags, convert(Vector{Cint}, numElements), length(numElements), heights, length(heights), recombine, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return outDimTags
end

"""
Translate the geometrical entities `dimTags' along (`dx', `dy', `dz').
"""
function translate(dimTags, dx, dy, dz)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGeoTranslate, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Ptr{Cint}),
          dimTags, dx, dy, dz, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Rotate the geometrical entities `dimTags' of `angle' radians around the axis of
revolution defined by the point (`x', `y', `z') and the direction (`ax', `ay',
`az').
"""
function rotate(dimTags, x, y, z, ax, ay, az, angle)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGeoRotate, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Ptr{Cint}),
          dimTags, x, y, z, ax, ay, az, angle, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Scale the geometrical entities `dimTag' by factors `a', `b' and `c' along the
three coordinate axes; use (`x', `y', `z') as the center of the homothetic
transformation.
"""
function dilate(dimTags, x, y, z, a, b, c)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGeoDilate, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Ptr{Cint}),
          dimTags, x, y, z, a, b, c, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Apply a symmetry transformation to the geometrical entities `dimTag', with
respect to the plane of equation `a' * x + `b' * y + `c' * z + `d' = 0.
"""
function symmetry(dimTags, a, b, c, d)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGeoSymmetry, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Cdouble, Ptr{Cint}),
          dimTags, a, b, c, d, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Copy the entities `dimTags'; the new entities are returned in `outDimTags'.

Return `outDimTags'.
"""
function copy(dimTags)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGeoCopy, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}),
          dimTags, outDimTags, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return outDimTags
end

"""
Remove the entities `dimTags'. If `recursive' is true, remove all the entities
on their boundaries, down to dimension 0.
"""
function remove(dimTags, recursive = false)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGeoRemove, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          dimTags, recursive, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Remove all duplicate entities (different entities at the same geometrical
location).
"""
function removeAllDuplicates()
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGeoRemoveAllDuplicates, gmsh.clib), Void,
          (Ptr{Cint},),
          ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Synchronize the internal GEO CAD representation with the current Gmsh model.
This can be called at any time, but since it involves a non trivial amount of
processing, the number of synchronization points should normally be minimized.
"""
function synchronize()
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGeoSynchronize, gmsh.clib), Void,
          (Ptr{Cint},),
          ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
GEO-specific meshing constraints
"""
module mesh

import ....gmsh

"""
Set a mesh size constraint on the geometrical entities `dimTags'. Currently only
entities of dimension 0 (points) are handled.
"""
function setSize(dimTags, size)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGeoMeshSetSize, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Ptr{Cint}),
          dimTags, size, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Set a transfinite meshing constraint on the curve `tag', with `numNodes' mesh
nodes distributed according to `meshType' and `coef'. Currently supported types
are "Progression" (geometrical progression with power `coef') and "Bump"
(refinement toward both extreminties of the curve).
"""
function setTransfiniteCurve(tag, nPoints, meshType = "Progression", coef = 1.)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGeoMeshSetTransfiniteCurve, gmsh.clib), Void,
          (Cint, Cint, Ptr{Cchar}, Cdouble, Ptr{Cint}),
          tag, nPoints, meshType, coef, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Set a transfinite meshing constraint on the surface `tag'. `arrangement'
describes the arrangement of the triangles when the surface is not flagged as
recombined: currently supported values are "Left", "Right", "AlternateLeft" and
"AlternateRight". `cornerTags' can be used to specify the (3 or 4) corners of
the transfinite interpolation explicitly; specifying the corners explicitly is
mandatory if the surface has more that 3 or 4 points on its boundary.
"""
function setTransfiniteSurface(tag, arrangement = "Left", cornerTags = std::vector<int>())
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGeoMeshSetTransfiniteSurface, gmsh.clib), Void,
          (Cint, Ptr{Cchar}, Ptr{Cint}, Csize_t, Ptr{Cint}),
          tag, arrangement, convert(Vector{Cint}, cornerTags), length(cornerTags), ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Set a transfinite meshing constraint on the surface `tag'. `cornerTags' can be
used to specify the (6 or 8) corners of the transfinite interpolation
explicitly.
"""
function setTransfiniteVolume(tag, cornerTags = std::vector<int>())
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGeoMeshSetTransfiniteVolume, gmsh.clib), Void,
          (Cint, Ptr{Cint}, Csize_t, Ptr{Cint}),
          tag, convert(Vector{Cint}, cornerTags), length(cornerTags), ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Set a recombination meshing constraint on the geometrical entity of dimension
`dim' and tag `tag'. Currently only entities of dimension 2 (to recombine
triangles into quadrangles) are supported.
"""
function setRecombine(dim, tag, angle = 45.)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGeoMeshSetRecombine, gmsh.clib), Void,
          (Cint, Cint, Cdouble, Ptr{Cint}),
          dim, tag, angle, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Set a smoothing meshing constraint on the geometrical entity of dimension `dim'
and tag `tag'. `val' iterations of a Laplace smoother are applied.
"""
function setSmoothing(dim, tag, val)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGeoMeshSetSmoothing, gmsh.clib), Void,
          (Cint, Cint, Cint, Ptr{Cint}),
          dim, tag, val, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Set a reverse meshing constraint on the geometrical entity of dimension `dim'
and tag `tag'. If `val' is true, the mesh orientation will be reversed with
respect to the natural mesh orientation (i.e. the orientation consistent with
the orientation of the geometrical entity). If `val' is false, the mesh is left
as-is.
"""
function setReverse(dim, tag, val = true)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelGeoMeshSetReverse, gmsh.clib), Void,
          (Cint, Cint, Cint, Ptr{Cint}),
          dim, tag, val, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

end # end of module mesh

end # end of module geo

"""
Internal per-model OpenCASCADE CAD kernel functions
"""
module occ

import ...gmsh

"""
Add a geometrical point in the internal OpenCASCADE CAD representation, at
coordinates (x, y, z). If `meshSize' is > 0, add a meshing constraint at that
point. If `tag' is positive, set the tag explicitly; otherwise a new tag is
selected automatically. Return the tag of the point. (Note that the point will
be added in the current model only after `synchronize' is called. This behavior
holds for all the entities added in the occ module.)

Return an integer.
"""
function addPoint(x, y, z, meshSize = 0., tag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelOccAddPoint, gmsh.clib), Cint,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cint, Ptr{Cint}),
          x, y, z, meshSize, tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a straight line segment between the two points with tags `startTag' and
`endTag'. If `tag' is positive, set the tag explicitly; otherwise a new tag is
selected automatically. Return the tag of the line.

Return an integer.
"""
function addLine(startTag, endTag, tag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelOccAddLine, gmsh.clib), Cint,
          (Cint, Cint, Cint, Ptr{Cint}),
          startTag, endTag, tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a circle arc between the two points with tags `startTag' and `endTag', with
center `centerTag'. If `tag' is positive, set the tag explicitly; otherwise a
new tag is selected automatically. Return the tag of the circle arc.

Return an integer.
"""
function addCircleArc(startTag, centerTag, endTag, tag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelOccAddCircleArc, gmsh.clib), Cint,
          (Cint, Cint, Cint, Cint, Ptr{Cint}),
          startTag, centerTag, endTag, tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a circle of center (`x', `y', `z') and radius `r'. If `tag' is positive, set
the tag explicitly; otherwise a new tag is selected automatically. If `angle1'
and `angle2' are specified, create a circle arc between the two angles. Return
the tag of the circle.

Return an integer.
"""
function addCircle(x, y, z, r, tag = -1, angle1 = 0., angle2 = 2*M_PI)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelOccAddCircle, gmsh.clib), Cint,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cint, Cdouble, Cdouble, Ptr{Cint}),
          x, y, z, r, tag, angle1, angle2, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add an ellipse arc between the two points with tags `startTag' and `endTag',
with center `centerTag'. If `tag' is positive, set the tag explicitly; otherwise
a new tag is selected automatically. Return the tag of the ellipse arc.

Return an integer.
"""
function addEllipseArc(startTag, centerTag, endTag, tag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelOccAddEllipseArc, gmsh.clib), Cint,
          (Cint, Cint, Cint, Cint, Ptr{Cint}),
          startTag, centerTag, endTag, tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add an ellipse of center (`x', `y', `z') and radii `r1' and `r2' along the x-
and y-axes respectively. If `tag' is positive, set the tag explicitly; otherwise
a new tag is selected automatically. If `angle1' and `angle2' are specified,
create an ellipse arc between the two angles. Return the tag of the ellipse.

Return an integer.
"""
function addEllipse(x, y, z, r1, r2, tag = -1, angle1 = 0., angle2 = 2*M_PI)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelOccAddEllipse, gmsh.clib), Cint,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cint, Cdouble, Cdouble, Ptr{Cint}),
          x, y, z, r1, r2, tag, angle1, angle2, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a spline (C2 b-spline) curve going through the points `pointTags'. If `tag'
is positive, set the tag explicitly; otherwise a new tag is selected
automatically. Create a periodic curve if the first and last points are the
same. Return the tag of the spline curve.

Return an integer.
"""
function addSpline(pointTags, tag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelOccAddSpline, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, pointTags), length(pointTags), tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a b-spline curve of degree `degree' with `pointTags' control points. If
`weights', `knots' or `multiplicities' are not provided, default parameters are
computed automatically. If `tag' is positive, set the tag explicitly; otherwise
a new tag is selected automatically. Create a periodic curve if the first and
last points are the same. Return the tag of the b-spline curve.

Return an integer.
"""
function addBSpline(pointTags, tag = -1, degree = 3, weights = std::vector<double>(), knots = std::vector<double>(), multiplicities = std::vector<int>())
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelOccAddBSpline, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Cint, Ptr{Cdouble}, Csize_t, Ptr{Cdouble}, Csize_t, Ptr{Cint}, Csize_t, Ptr{Cint}),
          convert(Vector{Cint}, pointTags), length(pointTags), tag, degree, weights, length(weights), knots, length(knots), convert(Vector{Cint}, multiplicities), length(multiplicities), ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a Bezier curve with `pointTags' control points. If `tag' is positive, set
the tag explicitly; otherwise a new tag is selected automatically. Return the
tag of the Bezier curve.

Return an integer.
"""
function addBezier(pointTags, tag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelOccAddBezier, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, pointTags), length(pointTags), tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a wire (open or closed) formed by the curves `curveTags'. `curveTags' should
contain (signed) tags: a negative tag signifies that the underlying curve is
considered with reversed orientation. If `tag' is positive, set the tag
explicitly; otherwise a new tag is selected automatically. Return the tag of the
wire.

Return an integer.
"""
function addWire(curveTags, tag = -1, checkClosed = false)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelOccAddWire, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Cint, Ptr{Cint}),
          convert(Vector{Cint}, curveTags), length(curveTags), tag, checkClosed, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a curve loop (a closed wire) formed by the curves `curveTags'. `curveTags'
should contain (signed) tags of curves forming a closed loop: a negative tag
signifies that the underlying curve is considered with reversed orientation. If
`tag' is positive, set the tag explicitly; otherwise a new tag is selected
automatically. Return the tag of the curve loop.

Return an integer.
"""
function addCurveLoop(curveTags, tag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelOccAddCurveLoop, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, curveTags), length(curveTags), tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a rectangle with lower left corner at (`x', `y', `z') and upper right corner
at (`x' + `dx', `y' + `dy', `z'). If `tag' is positive, set the tag explicitly;
otherwise a new tag is selected automatically. Round the corners if
`roundedRadius' is nonzero. Return the tag of the rectangle.

Return an integer.
"""
function addRectangle(x, y, z, dx, dy, tag = -1, roundedRadius = 0.)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelOccAddRectangle, gmsh.clib), Cint,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cint, Cdouble, Ptr{Cint}),
          x, y, z, dx, dy, tag, roundedRadius, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a disk with center (`xc', `yc', `zc') and radius `rx' along the x-axis and
`ry' along the y-axis. If `tag' is positive, set the tag explicitly; otherwise a
new tag is selected automatically. Return the tag of the disk.

Return an integer.
"""
function addDisk(xc, yc, zc, rx, ry, tag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelOccAddDisk, gmsh.clib), Cint,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cint, Ptr{Cint}),
          xc, yc, zc, rx, ry, tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a plane surface defined by one or more curve loops (or closed wires)
`wireTags'. The first curve loop defines the exterior contour; additional curve
loop define holes. If `tag' is positive, set the tag explicitly; otherwise a new
tag is selected automatically. Return the tag of the surface.

Return an integer.
"""
function addPlaneSurface(wireTags, tag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelOccAddPlaneSurface, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, wireTags), length(wireTags), tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a surface filling the curve loops in `wireTags'. If `tag' is positive, set
the tag explicitly; otherwise a new tag is selected automatically. Return the
tag of the surface.

Return an integer.
"""
function addSurfaceFilling(wireTag, tag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelOccAddSurfaceFilling, gmsh.clib), Cint,
          (Cint, Cint, Ptr{Cint}),
          wireTag, tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a surface loop (a closed shell) formed by `surfaceTags'.  If `tag' is
positive, set the tag explicitly; otherwise a new tag is selected automatically.
Return the tag of the surface loop.

Return an integer.
"""
function addSurfaceLoop(surfaceTags, tag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelOccAddSurfaceLoop, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, surfaceTags), length(surfaceTags), tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a volume (a region) defined by one or more surface loops `shellTags'. The
first surface loop defines the exterior boundary; additional surface loop define
holes. If `tag' is positive, set the tag explicitly; otherwise a new tag is
selected automatically. Return the tag of the volume.

Return an integer.
"""
function addVolume(shellTags, tag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelOccAddVolume, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, shellTags), length(shellTags), tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a sphere of center (`xc', `yc', `zc') and radius `r'. The optional `angle1'
and `angle2' arguments define the polar angle opening (from -Pi/2 to Pi/2). The
optional `angle3' argument defines the azimuthal opening (from 0 to 2*Pi). If
`tag' is positive, set the tag explicitly; otherwise a new tag is selected
automatically. Return the tag of the sphere.

Return an integer.
"""
function addSphere(xc, yc, zc, radius, tag = -1, angle1 = -M_PI/2, angle2 = M_PI/2, angle3 = 2*M_PI)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelOccAddSphere, gmsh.clib), Cint,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cint, Cdouble, Cdouble, Cdouble, Ptr{Cint}),
          xc, yc, zc, radius, tag, angle1, angle2, angle3, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a parallelepipedic box defined by a point (`x', `y', `z') and the extents
along the x-, y- and z-axes. If `tag' is positive, set the tag explicitly;
otherwise a new tag is selected automatically. Return the tag of the box.

Return an integer.
"""
function addBox(x, y, z, dx, dy, dz, tag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelOccAddBox, gmsh.clib), Cint,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cint, Ptr{Cint}),
          x, y, z, dx, dy, dz, tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a cylinder, defined by the center (`x', `y', `z') of its first circular
face, the 3 components (`dx', `dy', `dz') of the vector defining its axis and
its radius `r'. The optional `angle' argument defines the angular opening (from
0 to 2*Pi). If `tag' is positive, set the tag explicitly; otherwise a new tag is
selected automatically. Return the tag of the cylinder.

Return an integer.
"""
function addCylinder(x, y, z, dx, dy, dz, r, tag = -1, angle = 2*M_PI)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelOccAddCylinder, gmsh.clib), Cint,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cint, Cdouble, Ptr{Cint}),
          x, y, z, dx, dy, dz, r, tag, angle, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a cone, defined by the center (`x', `y', `z') of its first circular face,
the 3 components of the vector (`dx', `dy', `dz') defining its axis and the two
radii `r1' and `r2' of the faces (these radii can be zero). If `tag' is
positive, set the tag explicitly; otherwise a new tag is selected automatically.
`angle' defines the optional angular opening (from 0 to 2*Pi). Return the tag of
the cone.

Return an integer.
"""
function addCone(x, y, z, dx, dy, dz, r1, r2, tag = -1, angle = 2*M_PI)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelOccAddCone, gmsh.clib), Cint,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cint, Cdouble, Ptr{Cint}),
          x, y, z, dx, dy, dz, r1, r2, tag, angle, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a right angular wedge, defined by the right-angle point (`x', `y', `z') and
the 3 extends along the x-, y- and z-axes (`dx', `dy', `dz'). If `tag' is
positive, set the tag explicitly; otherwise a new tag is selected automatically.
The optional argument `ltx' defines the top extent along the x-axis. Return the
tag of the wedge.

Return an integer.
"""
function addWedge(x, y, z, dx, dy, dz, tag = -1, ltx = 0.)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelOccAddWedge, gmsh.clib), Cint,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cint, Cdouble, Ptr{Cint}),
          x, y, z, dx, dy, dz, tag, ltx, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a torus, defined by its center (`x', `y', `z') and its 2 radii `r' and `r2'.
If `tag' is positive, sets the tag explicitly; otherwise a new tag is selected
automatically. The optional argument `angle' defines the angular opening (from 0
to 2*Pi). Return the tag of the wedge.

Return an integer.
"""
function addTorus(x, y, z, r1, r2, tag = -1, angle = 2*M_PI)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshModelOccAddTorus, gmsh.clib), Cint,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cint, Cdouble, Ptr{Cint}),
          x, y, z, r1, r2, tag, angle, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Add a volume (if the optional argument `makeSolid' is set) or surfaces defined
through the open or closed wires `wireTags'. If `tag' is positive, set the tag
explicitly; otherwise a new tag is selected automatically. The new entities are
returned in `outDimTags'. If the optional argument `makeRuled' is set, the
surfaces created on the boundary are forced to be ruled surfaces.

Return `outDimTags'.
"""
function addThruSections(wireTags, tag = -1, makeSolid = true, makeRuled = false)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelOccAddThruSections, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Cint, Cint, Cint, Ptr{Cint}),
          convert(Vector{Cint}, wireTags), length(wireTags), outDimTags, tag, makeSolid, makeRuled, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return outDimTags
end

"""
Add a hollowed volume built from an initial volume `volumeTag' and a set of
faces from this volume `excludeSurfaceTags', which are to be removed. The
remaining faces of the volume become the walls of the hollowed solid, with
thickness `offset'. If `tag' is positive, set the tag explicitly; otherwise a
new tag is selected automatically.

Return `outDimTags'.
"""
function addThickSolid(volumeTag, excludeSurfaceTags, offset, tag = -1)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelOccAddThickSolid, gmsh.clib), Void,
          (Cint, Ptr{Cint}, Csize_t, Cdouble, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Cint, Ptr{Cint}),
          volumeTag, convert(Vector{Cint}, excludeSurfaceTags), length(excludeSurfaceTags), offset, outDimTags, tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return outDimTags
end

"""
Extrude the geometrical entities `dimTags' by translation along (`dx', `dy',
`dz'). Return extruded entities in `outDimTags'. If `numElements' is not empty,
also extrude the mesh: the entries in `numElements' give the number of elements
in each layer. If `height' is not empty, it provides the (cummulative) height of
the different layers, normalized to 1.

Return `outDimTags'.
"""
function extrude(dimTags, dx, dy, dz, numElements = std::vector<int>(), heights = std::vector<double>(), recombine = false)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelOccExtrude, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}, Csize_t, Ptr{Cdouble}, Csize_t, Cint, Ptr{Cint}),
          dimTags, dx, dy, dz, outDimTags, convert(Vector{Cint}, numElements), length(numElements), heights, length(heights), recombine, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return outDimTags
end

"""
Extrude the geometrical entities `dimTags' by rotation of `angle' radians around
the axis of revolution defined by the point (`x', `y', `z') and the direction
(`ax', `ay', `az'). Return extruded entities in `outDimTags'. If `numElements'
is not empty, also extrude the mesh: the entries in `numElements' give the
number of elements in each layer. If `height' is not empty, it provides the
(cummulative) height of the different layers, normalized to 1.

Return `outDimTags'.
"""
function revolve(dimTags, x, y, z, ax, ay, az, angle, numElements = std::vector<int>(), heights = std::vector<double>(), recombine = false)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelOccRevolve, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}, Csize_t, Ptr{Cdouble}, Csize_t, Cint, Ptr{Cint}),
          dimTags, x, y, z, ax, ay, az, angle, outDimTags, convert(Vector{Cint}, numElements), length(numElements), heights, length(heights), recombine, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return outDimTags
end

"""
Add a pipe by extruding the entities `dimTags' along the wire `wireTag'. Return
the pipe in `outDimTags'.

Return `outDimTags'.
"""
function addPipe(dimTags, wireTag)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelOccAddPipe, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}),
          dimTags, wireTag, outDimTags, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return outDimTags
end

"""
Fillet the volumes `volumeTags' on the curves `curveTags' with radius `radius'.
Return the filleted entities in `outDimTags'. Remove the original volume if
`removeVolume' is set.

Return `outDimTags'.
"""
function fillet(volumeTags, curveTags, radius, removeVolume = true)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelOccFillet, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Ptr{Cint}, Csize_t, Cdouble, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Cint, Ptr{Cint}),
          convert(Vector{Cint}, volumeTags), length(volumeTags), convert(Vector{Cint}, curveTags), length(curveTags), radius, outDimTags, removeVolume, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return outDimTags
end

"""
Compute the boolean union (the fusion) of the entities `objectDimTags' and
`toolDimTags'. Return the resulting entities in `outDimTags'. If `tag' is
positive, try to set the tag explicitly (ony valid if the boolean operation
results in a single entity). Remove the object if `removeObject' is set. Remove
the tool if `removeTool' is set.

Return `outDimTags', `outDimTagsMap'.
"""
function fuse(objectDimTags, toolDimTags, tag = -1, removeObject = true, removeTool = true)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelOccFuse, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Ptr{Cint}, Csize_t, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Ptr{Ptr{Cint}}}, Ptr{Ptr{Csize_t}}, Ptr{Csize_t}, Cint, Cint, Cint, Ptr{Cint}),
          objectDimTags, toolDimTags, outDimTags, outDimTagsMap, tag, removeObject, removeTool, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return outDimTags, outDimTagsMap
end

"""
Compute the boolean intersection (the common parts) of the entities
`objectDimTags' and `toolDimTags'. Return the resulting entities in
`outDimTags'. If `tag' is positive, try to set the tag explicitly (ony valid if
the boolean operation results in a single entity). Remove the object if
`removeObject' is set. Remove the tool if `removeTool' is set.

Return `outDimTags', `outDimTagsMap'.
"""
function intersect(objectDimTags, toolDimTags, tag = -1, removeObject = true, removeTool = true)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelOccIntersect, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Ptr{Cint}, Csize_t, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Ptr{Ptr{Cint}}}, Ptr{Ptr{Csize_t}}, Ptr{Csize_t}, Cint, Cint, Cint, Ptr{Cint}),
          objectDimTags, toolDimTags, outDimTags, outDimTagsMap, tag, removeObject, removeTool, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return outDimTags, outDimTagsMap
end

"""
Compute the boolean difference between the entities `objectDimTags' and
`toolDimTags'. Return the resulting entities in `outDimTags'. If `tag' is
positive, try to set the tag explicitly (ony valid if the boolean operation
results in a single entity). Remove the object if `removeObject' is set. Remove
the tool if `removeTool' is set.

Return `outDimTags', `outDimTagsMap'.
"""
function cut(objectDimTags, toolDimTags, tag = -1, removeObject = true, removeTool = true)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelOccCut, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Ptr{Cint}, Csize_t, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Ptr{Ptr{Cint}}}, Ptr{Ptr{Csize_t}}, Ptr{Csize_t}, Cint, Cint, Cint, Ptr{Cint}),
          objectDimTags, toolDimTags, outDimTags, outDimTagsMap, tag, removeObject, removeTool, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return outDimTags, outDimTagsMap
end

"""
Compute the boolean fragments (general fuse) of the entities `objectDimTags' and
`toolDimTags'. Return the resulting entities in `outDimTags'. If `tag' is
positive, try to set the tag explicitly (ony valid if the boolean operation
results in a single entity). Remove the object if `removeObject' is set. Remove
the tool if `removeTool' is set.

Return `outDimTags', `outDimTagsMap'.
"""
function fragment(objectDimTags, toolDimTags, tag = -1, removeObject = true, removeTool = true)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelOccFragment, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Ptr{Cint}, Csize_t, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Ptr{Ptr{Cint}}}, Ptr{Ptr{Csize_t}}, Ptr{Csize_t}, Cint, Cint, Cint, Ptr{Cint}),
          objectDimTags, toolDimTags, outDimTags, outDimTagsMap, tag, removeObject, removeTool, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return outDimTags, outDimTagsMap
end

"""
Translate the geometrical entities `dimTags' along (`dx', `dy', `dz').
"""
function translate(dimTags, dx, dy, dz)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelOccTranslate, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Ptr{Cint}),
          dimTags, dx, dy, dz, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Rotate the geometrical entities `dimTags' of `angle' radians around the axis of
revolution defined by the point (`x', `y', `z') and the direction (`ax', `ay',
`az').
"""
function rotate(dimTags, x, y, z, ax, ay, az, angle)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelOccRotate, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Ptr{Cint}),
          dimTags, x, y, z, ax, ay, az, angle, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Scale the geometrical entities `dimTag' by factors `a', `b' and `c' along the
three coordinate axes; use (`x', `y', `z') as the center of the homothetic
transformation.
"""
function dilate(dimTags, x, y, z, a, b, c)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelOccDilate, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Ptr{Cint}),
          dimTags, x, y, z, a, b, c, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Apply a symmetry transformation to the geometrical entities `dimTag', with
respect to the plane of equation `a' * x + `b' * y + `c' * z + `d' = 0.
"""
function symmetry(dimTags, a, b, c, d)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelOccSymmetry, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Cdouble, Ptr{Cint}),
          dimTags, a, b, c, d, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Copy the entities `dimTags'; the new entities are returned in `outDimTags'.

Return `outDimTags'.
"""
function copy(dimTags)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelOccCopy, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}),
          dimTags, outDimTags, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return outDimTags
end

"""
Remove the entities `dimTags'. If `recursive' is true, remove all the entities
on their boundaries, down to dimension 0.
"""
function remove(dimTags, recursive = false)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelOccRemove, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          dimTags, recursive, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Remove all duplicate entities (different entities at the same geometrical
location) after intersecting (using boolean fragments) all highest dimensional
entities.
"""
function removeAllDuplicates()
    ierr = Vector{Cint}(1)
    ccall((:gmshModelOccRemoveAllDuplicates, gmsh.clib), Void,
          (Ptr{Cint},),
          ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Import BREP, STEP or IGES shapes from the file `fileName'. The imported entities
are returned in `outDimTags'. If the optional argument `highestDimOnly' is set,
only import the highest dimensional entities in the file. The optional argument
`format' can be used to force the format of the file (currently "brep", "step"
or "iges").

Return `outDimTags'.
"""
function importShapes(fileName, highestDimOnly = true, format = "")
    ierr = Vector{Cint}(1)
    ccall((:gmshModelOccImportShapes, gmsh.clib), Void,
          (Ptr{Cchar}, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Cint, Ptr{Cchar}, Ptr{Cint}),
          fileName, outDimTags, highestDimOnly, format, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return outDimTags
end

"""
Set a mesh size constraint on the geometrical entities `dimTags'. Currently only
entities of dimension 0 (points) are handled.
"""
function setMeshSize(dimTags, size)
    ierr = Vector{Cint}(1)
    ccall((:gmshModelOccSetMeshSize, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Ptr{Cint}),
          dimTags, size, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Synchronize the internal OpenCASCADE CAD representation with the current Gmsh
model. This can be called at any time, but since it involves a non trivial
amount of processing, the number of synchronization points should normally be
minimized.
"""
function synchronize()
    ierr = Vector{Cint}(1)
    ccall((:gmshModelOccSynchronize, gmsh.clib), Void,
          (Ptr{Cint},),
          ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

end # end of module occ

end # end of module model

"""
Post-processing view functions
"""
module view

import ..gmsh

"""
Add a new post-processing view, with name `name'. If `tag' is positive use it
(and remove the view with that tag if it already exists), otherwise associate a
new tag. Return the view tag.

Return an integer.
"""
function add(name, tag = -1)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshViewAdd, gmsh.clib), Cint,
          (Ptr{Cchar}, Cint, Ptr{Cint}),
          name, tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Remove the view with tag `tag'.
"""
function remove(tag)
    ierr = Vector{Cint}(1)
    ccall((:gmshViewRemove, gmsh.clib), Void,
          (Cint, Ptr{Cint}),
          tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Get the index of the view with tag `tag' in the list of currently loaded views.
This dynamic index (it can change when views are removed) is used to access view
options.

Return an integer.
"""
function getIndex(tag)
    ierr = Vector{Cint}(1)
    api__result__ = ccall((:gmshViewGetIndex, gmsh.clib), Cint,
          (Cint, Ptr{Cint}),
          tag, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return api__result__
end

"""
Get the tags of all views.

Return `tags'.
"""
function getTags()
    api_tags_= Vector{Ptr{Cint}}(1)
    api_tags_n_= Vector{Csize_t}(1)
    ierr = Vector{Cint}(1)
    ccall((:gmshViewGetTags, gmsh.clib), Void,
          (Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}),
          api_tags_, api_tags_n_, ierr)
    tags = unsafe_wrap(Array, api_tags_[1], api_tags_n_[1], true)
    if ierr[1] != 0
      println(ierr[1])
    end
    return tags
end

"""
Add model-based post-processing data to the view with tag `tag'. `modelName'
identifies the model the data is attached to. `dataType' specifies the type of
data, currently either "NodeData", "ElementData" or "ElementNodeData". `step'
specifies the identifier (>= 0) of the data in a sequence. `tags' gives the tags
of the nodes or elements in the mesh to which the data is associated. `data' is
a vector of the same length as `tags': each entry is the vector of double
precision numbers representing the data associated with the corresponding tag.
The optional `time' argument associate a time value with the data.
`numComponents' gives the number of data components (1 for scalar data, 3 for
vector data, etc.) per entity; if negative, it is automatically inferred (when
possible) from the input data. `partition' allows to specify data in several
sub-sets.
"""
function addModelData(tag, step, modelName, dataType, tags, data, time = 0., numComponents = -1, partition = 0)
    ierr = Vector{Cint}(1)
    ccall((:gmshViewAddModelData, gmsh.clib), Void,
          (Cint, Cint, Ptr{Cchar}, Ptr{Cchar}, Ptr{Cint}, Csize_t, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Csize_t, Cdouble, Cint, Cint, Ptr{Cint}),
          tag, step, modelName, dataType, convert(Vector{Cint}, tags), length(tags), data, time, numComponents, partition, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Get model-based post-processing data from the view with tag `tag' at step
`step'. Return the `data' associated to the nodes or the elements with tags
`tags', as well as the `dataType' and the number of components `numComponents'.

Return `dataType', `tags', `data', `time', `numComponents'.
"""
function getModelData(tag, step)
    api_tags_= Vector{Ptr{Cint}}(1)
    api_tags_n_= Vector{Csize_t}(1)
    ierr = Vector{Cint}(1)
    ccall((:gmshViewGetModelData, gmsh.clib), Void,
          (Cint, Cint, Ptr{Ptr{Cchar}}, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Ptr{Ptr{Cdouble}}}, Ptr{Ptr{Csize_t}}, Ptr{Csize_t}, Ptr{Cdouble}, Ptr{Cint}, Ptr{Cint}),
          tag, step, dataType, api_tags_, api_tags_n_, data, time, numComponents, ierr)
    tags = unsafe_wrap(Array, api_tags_[1], api_tags_n_[1], true)
    if ierr[1] != 0
      println(ierr[1])
    end
    return dataType, tags, data, time, numComponents
end

"""
Add list-based post-processing data to the view with tag `tag'. `dataType'
identifies the data: "SP" for scalar points, "VP", for vector points, etc.
`numEle' gives the number of elements in the data. `data' contains the data for
the `numEle' elements.
"""
function addListData(tag, dataType, numEle, data)
    ierr = Vector{Cint}(1)
    ccall((:gmshViewAddListData, gmsh.clib), Void,
          (Cint, Ptr{Cchar}, Cint, Ptr{Cdouble}, Csize_t, Ptr{Cint}),
          tag, dataType, numEle, data, length(data), ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Get list-based post-processing data from the view with tag `tag'. Return the
types `dataTypes', the number of elements `numElements' for each data type and
the `data' for each data type.

Return `dataType', `numElements', `data'.
"""
function getListData(tag)
    api_numElements_= Vector{Ptr{Cint}}(1)
    api_numElements_n_= Vector{Csize_t}(1)
    ierr = Vector{Cint}(1)
    ccall((:gmshViewGetListData, gmsh.clib), Void,
          (Cint, Ptr{Ptr{Cchar}}, Ptr{Csize_t}, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Ptr{Ptr{Cdouble}}}, Ptr{Ptr{Csize_t}}, Ptr{Csize_t}, Ptr{Cint}),
          tag, dataType, api_numElements_, api_numElements_n_, data, ierr)
    numElements = unsafe_wrap(Array, api_numElements_[1], api_numElements_n_[1], true)
    if ierr[1] != 0
      println(ierr[1])
    end
    return dataType, numElements, data
end

"""
Probe the view `tag' for its `value' at point (`x', `y', `z'). Return only the
value at step `step' is `step' is positive. Return only values with `numComp' if
`numComp' is positive. Return the gradient of the `value' if `gradient' is set.
Probes with a geometrical tolerance (in the reference unit cube) of `tolerance'
if `tolerance' is not zero. Return the result from the element described by its
coordinates if `xElementCoord', `yElementCoord' and `zElementCoord' are
provided.

Return `value'.
"""
function probe(tag, x, y, z, step = -1, numComp = -1, gradient = false, tolerance = 0., xElemCoord = std::vector<double>(), yElemCoord = std::vector<double>(), zElemCoord = std::vector<double>())
    api_value_= Vector{Ptr{Cdouble}}(1)
    api_value_n_= Vector{Csize_t}(1)
    ierr = Vector{Cint}(1)
    ccall((:gmshViewProbe, gmsh.clib), Void,
          (Cint, Cdouble, Cdouble, Cdouble, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Cint, Cint, Cint, Cdouble, Ptr{Cdouble}, Csize_t, Ptr{Cdouble}, Csize_t, Ptr{Cdouble}, Csize_t, Ptr{Cint}),
          tag, x, y, z, api_value_, api_value_n_, step, numComp, gradient, tolerance, xElemCoord, length(xElemCoord), yElemCoord, length(yElemCoord), zElemCoord, length(zElemCoord), ierr)
    value = unsafe_wrap(Array, api_value_[1], api_value_n_[1], true)
    if ierr[1] != 0
      println(ierr[1])
    end
    return value
end

"""
Write the view to a file `fileName'. The export format is determined by the file
extension. Append to the file if `append' is set.
"""
function write(tag, fileName, append = false)
    ierr = Vector{Cint}(1)
    ccall((:gmshViewWrite, gmsh.clib), Void,
          (Cint, Ptr{Cchar}, Cint, Ptr{Cint}),
          tag, fileName, append, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

end # end of module view

"""
Plugin functions
"""
module plugin

import ..gmsh

"""
Set the numerical option `option' to the value `value' for plugin `name'.
"""
function setNumber(name, option, value)
    ierr = Vector{Cint}(1)
    ccall((:gmshPluginSetNumber, gmsh.clib), Void,
          (Ptr{Cchar}, Ptr{Cchar}, Cdouble, Ptr{Cint}),
          name, option, value, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Set the string option `option' to the value `value' for plugin `name'.
"""
function setString(name, option, value)
    ierr = Vector{Cint}(1)
    ccall((:gmshPluginSetString, gmsh.clib), Void,
          (Ptr{Cchar}, Ptr{Cchar}, Ptr{Cchar}, Ptr{Cint}),
          name, option, value, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Run the plugin `name'.
"""
function run(name)
    ierr = Vector{Cint}(1)
    ccall((:gmshPluginRun, gmsh.clib), Void,
          (Ptr{Cchar}, Ptr{Cint}),
          name, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

end # end of module plugin

"""
Graphics functions
"""
module graphics

import ..gmsh

"""
Draw all the OpenGL scenes.
"""
function draw()
    ierr = Vector{Cint}(1)
    ccall((:gmshGraphicsDraw, gmsh.clib), Void,
          (Ptr{Cint},),
          ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

end # end of module graphics

"""
Fltk graphical user interface functions
"""
module fltk

import ..gmsh

"""
Create the Fltk graphical user interface.
"""
function initialize()
    ierr = Vector{Cint}(1)
    ccall((:gmshFltkInitialize, gmsh.clib), Void,
          (Ptr{Cint},),
          ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Wait at most `time' seconds for user interface events and return. If `time' < 0,
wait indefinitely. First automatically create the user interface if it has not
yet been initialized.
"""
function wait(time = -1.)
    ierr = Vector{Cint}(1)
    ccall((:gmshFltkWait, gmsh.clib), Void,
          (Cdouble, Ptr{Cint}),
          time, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Run the event loop of the Fltk graphical user interface, i.e. repeatedly calls
`wait'. First automatically create the user interface if it has not yet been
initialized.
"""
function run()
    ierr = Vector{Cint}(1)
    ccall((:gmshFltkRun, gmsh.clib), Void,
          (Ptr{Cint},),
          ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

end # end of module fltk

"""
ONELAB server functions
"""
module onelab

import ..gmsh

"""
Get `data' from the ONELAB server.

Return `data'.
"""
function get(format = "json")
    ierr = Vector{Cint}(1)
    ccall((:gmshOnelabGet, gmsh.clib), Void,
          (Ptr{Ptr{Cchar}}, Ptr{Cchar}, Ptr{Cint}),
          data, format, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
    return data
end

"""
Set `data' in the ONELAB server.
"""
function set(data, format = "json")
    ierr = Vector{Cint}(1)
    ccall((:gmshOnelabSet, gmsh.clib), Void,
          (Ptr{Cchar}, Ptr{Cchar}, Ptr{Cint}),
          data, format, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

"""
Run a ONELAB client. If `name' is provided, create a new ONELAB client with name
`name' and executes `command'. If not, try to run a client that might be linked
to the processed input files.
"""
function run(name = "", command = "")
    ierr = Vector{Cint}(1)
    ccall((:gmshOnelabRun, gmsh.clib), Void,
          (Ptr{Cchar}, Ptr{Cchar}, Ptr{Cint}),
          name, command, ierr)
    if ierr[1] != 0
      println(ierr[1])
    end
end

end # end of module onelab

end # end of module gmsh
