// Gmsh - Copyright (C) 1997-2018 C. Geuzaine, J.-F. Remacle
//
// See the LICENSE.txt file for license information. Please report all
// bugs and problems to the public mailing list <gmsh@onelab.info>.

#ifndef _GMSH_H_
#define _GMSH_H_

// This file defines the Gmsh C++ API.
//
// Do not edit it directly: it is automatically generated by `api/gen.py'.
//
// By design, the Gmsh C++ API is purely functional, and only uses elementary
// types from the standard library. A pure C as well as a Python API are also
// automatically generated by `api/gen.py': see `gmshc.h' and `gmsh.py'.
//
// See `demos/api' for examples on how to use the Gmsh API. In particular,
// `demos/api' contains C++ and Python versions of several of the `.geo'
// tutorials from `tutorials'.

#if defined(_MSC_VER)
#define _USE_MATH_DEFINES
#endif

#include <cmath>
#include <vector>
#include <string>

#if defined(GMSH_DLL)
#if defined(GMSH_DLL_EXPORT)
#define GMSH_API __declspec(dllexport)
#else
#define GMSH_API __declspec(dllimport)
#endif
#else
#define GMSH_API
#endif

namespace gmsh {

  // A geometrical entity in the Gmsh API is represented by two integers: its
  // dimension (dim = 0, 1, 2 or 3) and its tag (its unique, strictly positive
  // identifier). When dealing with multiple geometrical entities of possibly
  // different dimensions, the entities are packed as a vector of (dim, tag)
  // integer pairs.
  typedef std::vector<std::pair<int, int> > vector_pair;

}

namespace gmsh { // Top-level functions

  // Initializes Gmsh. This must be called before any call to the other functions
  // in the API. If `argc' and `argv' are provided, they will be handled in the
  // same way as the command line arguments in the Gmsh app. If `readConfigFiles'
  // is set, reads system Gmsh configuration files (gmshrc and gmsh-options).
  GMSH_API void initialize(int argc = 0, char ** argv = 0,
                           const bool readConfigFiles = true);

  // Finalizes Gmsh. This must be called when you are done using the Gmsh API.
  GMSH_API void finalize();

  // Opens a file. Equivalent to the `File->Open' menu in the Gmsh app. Handling of
  // the file depends on its extension and/or its contents.
  GMSH_API void open(const std::string & fileName);

  // Merges a file. Equivalent to the `File->Merge' menu in the Gmsh app. Handling
  // of the file depends on its extension and/or its contents.
  GMSH_API void merge(const std::string & fileName);

  // Writes a file. The export format is determined by the file extension.
  GMSH_API void write(const std::string & fileName);

  // Clears all loaded models and post-processing data, and adds a new empty model.
  GMSH_API void clear();

  namespace option { // Global option handling functions

    // Sets a numerical option to `value'. `name' is of the form "category.option"
    // or "category[num].option". Available categories and options are listed in
    // the Gmsh reference manual.
    GMSH_API void setNumber(const std::string & name,
                            const double value);

    // Gets the `value' of a numerical option.
    GMSH_API void getNumber(const std::string & name,
                            double & value);

    // Sets a string option to `value'.
    GMSH_API void setString(const std::string & name,
                            const std::string & value);

    // Gets the `value' of a string option.
    GMSH_API void getString(const std::string & name,
                            std::string & value);

  } // namespace option

  namespace model { // Per-model functions

    // Adds a new model, with name `name', and sets it as the current model.
    GMSH_API void add(const std::string & name);

    // Removes the current model.
    GMSH_API void remove();

    // Lists the names of all models.
    GMSH_API void list(std::vector<std::string> & names);

    // Sets the current model to the model with name `name'. If several models have
    // the same name, selects the one that was added first.
    GMSH_API void setCurrent(const std::string & name);

    // Gets all the (elementary) geometrical entities in the current model. If
    // `dim' is >= 0, returns only the entities of the specified dimension (e.g.
    // points if `dim' == 0). The entities are returned as a vector of (dim, tag)
    // integer pairs.
    GMSH_API void getEntities(gmsh::vector_pair & dimTags,
                              const int dim = -1);

    // Gets all the physical groups in the current model. If `dim' is >= 0, returns
    // only the entities of the specified dimension (e.g. physical points if `dim'
    // == 0). The entities are returned as a vector of (dim, tag) integer pairs.
    GMSH_API void getPhysicalGroups(gmsh::vector_pair & dimTags,
                                    const int dim = -1);

    // Gets the tags of all the (elementary) geometrical entities making up the
    // physical group of dimension `dim' and tag `tag'.
    GMSH_API void getEntitiesForPhysicalGroup(const int dim,
                                              const int tag,
                                              std::vector<int> & tags);

    // Adds a physical group of dimension `dim', grouping the elementary entities
    // with tags `tags'. The function returns the tag of the physical group, equal
    // to `tag' if `tag' is positive, or a new tag if `tag' < 0.
    GMSH_API int addPhysicalGroup(const int dim,
                                  const std::vector<int> & tags,
                                  const int tag = -1);

    // Sets the name of the physical group of dimension `dim' and tag `tag'.
    GMSH_API void setPhysicalName(const int dim,
                                  const int tag,
                                  const std::string & name);

    // Gets the name of the physical group of dimension `dim' and tag `tag'.
    GMSH_API void getPhysicalName(const int dim,
                                  const int tag,
                                  std::string & name);

    // Gets the boundary of the geometrical entities `dimTags'. Returns in
    // `outDimTags' the boundary of the individual entities (if `combined' is
    // false) or the boundary of the combined geometrical shape formed by all input
    // entities (if `combined' is true). Returns tags multiplied by the sign of the
    // boundary entity if `oriented' is true. Applies the boundary operator
    // recursively down to dimension 0 (i.e. to points) if `recursive' is true.
    GMSH_API void getBoundary(const gmsh::vector_pair & dimTags,
                              gmsh::vector_pair & outDimTags,
                              const bool combined = true,
                              const bool oriented = true,
                              const bool recursive = false);

    // Gets the (elementary) geometrical entities in the bounding box defined by
    // the two points (`xmin', `ymin', `zmin') and (`xmax', `ymax', `zmax'). If
    // `dim' is >= 0, returns only the entities of the specified dimension (e.g.
    // points if `dim' == 0).
    GMSH_API void getEntitiesInBoundingBox(const double xmin,
                                           const double ymin,
                                           const double zmin,
                                           const double xmax,
                                           const double ymax,
                                           const double zmax,
                                           gmsh::vector_pair & tags,
                                           const int dim = -1);

    // Gets the bounding box (`xmin', `ymin', `zmin'), (`xmax', `ymax', `zmax') of
    // the geometrical entity of dimension `dim' and tag `tag'.
    GMSH_API void getBoundingBox(const int dim,
                                 const int tag,
                                 double & xmin,
                                 double & ymin,
                                 double & zmin,
                                 double & xmax,
                                 double & ymax,
                                 double & zmax);

    // Adds a discrete geometrical entity (defined by a mesh) of dimension `dim' in
    // the current model. The function returns the tag of the new discrete entity,
    // equal to `tag' if `tag' is positive, or a new tag if `tag' < 0. `boundary'
    // specifies the tags of the entities on the boundary of the discrete entity,
    // if any. Specyfing `boundary' allows Gmsh to construct the topology of the
    // overall model.
    GMSH_API int addDiscreteEntity(const int dim,
                                   const int tag = -1,
                                   const std::vector<int> & boundary = std::vector<int>());

    // Removes the entities `dimTags' of the current model. If `recursive' is true,
    // removes all the entities on their boundaries, down to dimension 0.
    GMSH_API void removeEntities(const gmsh::vector_pair & dimTags,
                                 const bool recursive = false);

    // Gets the type of the entity of dimension `dim' and tag `tag'.
    GMSH_API void getType(const int dim,
                          const int tag,
                          std::string & type);

    namespace mesh { // Per-model meshing functions

      // Generates a mesh of the current model, up to dimension `dim' (0, 1, 2 or
      // 3).
      GMSH_API void generate(const int dim);

      // Partitions the mesh of the current model into `numPart' partitions.
      GMSH_API void partition(const int numPart);

      // Refines the mesh of the current model by uniformly splitting the elements.
      GMSH_API void refine();

      // Sets the order of the elements in the mesh of the current model to
      // `order'.
      GMSH_API void setOrder(const int order);

      // Removes duplicate mesh nodes in the mesh of the current model.
      GMSH_API void removeDuplicateNodes();

      // Gets the last entities (if any) where a meshing error occurred. Currently
      // only populated by the new 3D meshing algorithms.
      GMSH_API void getLastEntityError(gmsh::vector_pair & dimTags);

      // Gets the last mesh nodes (if any) where a meshing error occurred.
      // Currently only populated by the new 3D meshing algorithms.
      GMSH_API void getLastNodeError(std::vector<int> & nodeTags);

      // Gets the mesh nodes of the entity of dimension `dim' and `tag' tag. If
      // `tag' < 0, gets the nodes for all entities of dimension `dim'. If `dim'
      // and `tag' are negative, gets all the nodes in the mesh. `nodeTags'
      // contains the node tags (their unique, strictly positive identification
      // numbers). `coord' is a vector of length 3 times the length of `nodeTags'
      // that contains the (x, y, z) coordinates of the nodes, concatenated. If
      // `dim' >= 0, `parametricCoord' contains the parametric coordinates of the
      // nodes, if available. The length of `parametricCoord' can be 0 or `dim'
      // times the length of `nodeTags'.
      GMSH_API void getNodes(std::vector<int> & nodeTags,
                             std::vector<double> & coord,
                             std::vector<double> & parametricCoord,
                             const int dim = -1,
                             const int tag = -1);

      // Gets the mesh elements of the entity of dimension `dim' and `tag' tag. If
      // `tag' < 0, gets the elements for all entities of dimension `dim'. If `dim'
      // and `tag' are negative, gets all the elements in the mesh. `elementTypes'
      // contains the MSH types of the elements (e.g. `2' for 3-node triangles: see
      // `getElementProperties' to obtain the properties for a given element type).
      // `elementTags' is a vector of the same length as `elementTypes'; each entry
      // is a vector containing the tags (unique, strictly positive identifiers) of
      // the elements of the corresponding type. `nodeTags' is also a vector of the
      // same length as `elementTypes'; each entry is a vector of length equal to
      // the number of elements of the given type times the number of nodes for
      // this type of element, that contains the node tags of all the elements of
      // the given type, concatenated.
      GMSH_API void getElements(std::vector<int> & elementTypes,
                                std::vector<std::vector<int> > & elementTags,
                                std::vector<std::vector<int> > & nodeTags,
                                const int dim = -1,
                                const int tag = -1);

      // Gets the properties of an element of type `elementType': its name
      // (`elementName'), dimension (`dim'), order (`order'), number of nodes
      // (`numNodes') and parametric coordinates of nodes (`parametricCoord'
      // vector, of length `dim' times `numNodes').
      GMSH_API void getElementProperties(const int elementType,
                                         std::string & elementName,
                                         int & dim,
                                         int & order,
                                         int & numNodes,
                                         std::vector<double> & parametricCoord);

      // Gets the integration data for mesh elements of the entity of dimension
      // `dim' and `tag' tag. The data is returned by element type and by element,
      // in the same order as the data returned by `getElements'. `integrationType'
      // specifies the type of integration (e.g. "Gauss4") and `functionSpaceType'
      // specifies the function space (e.g. "IsoParametric"). `integrationPoints'
      // contains for each element type a vector (of length 4 times the number of
      // integration points) containing the parametric coordinates (u, v, w) and
      // the weight associated to the integration points. `integrationData'
      // contains for each element type a vector (of size 13 times the number of
      // integration points) containing the (x, y, z) coordinates of the
      // integration point, the determinant of the Jacobian and the 9 entries (by
      // row) of the 3x3 Jacobian matrix. If `functionSpaceType' is provided,
      // `functionSpaceNumComponents' returns the number of components returned by
      // the evaluation of a basis function in the space and `functionSpaceData'
      // contains for each element type the evaluation of the basis functions at
      // the integration points.
      GMSH_API void getIntegrationData(const std::string & integrationType,
                                       const std::string & functionSpaceType,
                                       std::vector<std::vector<double> > & integrationPoints,
                                       std::vector<std::vector<double> > & integrationData,
                                       int & functionSpaceNumComponents,
                                       std::vector<std::vector<double> > & functionSpaceData,
                                       const int dim = -1,
                                       const int tag = -1);

      // Gets the types of mesh elements in the entity of dimension `dim' and `tag'
      // tag. If `tag' < 0, gets the types for all entities of dimension `dim'. If
      // `dim' and `tag' are negative, gets all the types in the mesh.
      GMSH_API void getElementTypes(std::vector<int> & elementTypes,
                                    const int dim = -1,
                                    const int tag = -1);

      // Gets the mesh elements in the same way as `getElements', but for a single
      // `elementType'.
      GMSH_API void getElementsByType(const int elementType,
                                      std::vector<int> & elementTags,
                                      std::vector<int> & nodeTags,
                                      const int dim = -1,
                                      const int tag = -1);

      // Gets the integration data for mesh elements in the same way as
      // `getIntegrationData', but for a single `elementType'.
      GMSH_API void getIntegrationDataByType(const int elementType,
                                             const std::string & integrationType,
                                             const std::string & functionSpaceType,
                                             std::vector<double> & integrationPoints,
                                             std::vector<double> & integrationData,
                                             int & functionSpaceNumComponents,
                                             std::vector<double> & functionSpaceData,
                                             const int dim = -1,
                                             const int tag = -1);

      // Sets the mesh nodes in the geometrical entity of dimension `dim' and tag
      // `tag'. `nodetags' contains the node tags (their unique, strictly positive
      // identification numbers). `coord' is a vector of length 3 times the length
      // of `nodeTags' that contains the (x, y, z) coordinates of the nodes,
      // concatenated. The optional `parametricCoord' vector contains the
      // parametric coordinates of the nodes, if any. The length of
      // `parametricCoord' can be 0 or `dim' times the length of `nodeTags'.
      GMSH_API void setNodes(const int dim,
                             const int tag,
                             const std::vector<int> & nodeTags,
                             const std::vector<double> & coord,
                             const std::vector<double> & parametricCoord = std::vector<double>());

      // Sets the mesh elements of the entity of dimension `dim' and `tag' tag.
      // `types' contains the MSH types of the elements (e.g. `2' for 3-node
      // triangles: see the Gmsh reference manual). `elementTags' is a vector of
      // the same length as `types'; each entry is a vector containing the tags
      // (unique, strictly positive identifiers) of the elements of the
      // corresponding type. `nodeTags' is also a vector of the same length as
      // `types'; each entry is a vector of length equal to the number of elements
      // of the give type times the number of nodes per element, that contains the
      // node tags of all the elements of the given type, concatenated.
      GMSH_API void setElements(const int dim,
                                const int tag,
                                const std::vector<int> & types,
                                const std::vector<std::vector<int> > & elementTags,
                                const std::vector<std::vector<int> > & nodeTags);

      // Redistributes all mesh nodes on their associated geometrical entity, based
      // on the mesh elements. Can be used when importing mesh nodes in bulk (e.g.
      // by associating them all to a single volume), to reclassify them correctly
      // on model surfaces, curves, etc.
      GMSH_API void reclassifyNodes();

      // Gets the coordinates and the parametric coordinates (if any) of the mesh
      // node with tag `tag'. This is a useful by inefficient way of accessing mesh
      // node data, as it relies on a cache stored in the model. For large meshes
      // all the nodes in the model should be numbered in a continuous sequence of
      // tags from 1 to N to maintain reasonnable performance (in this case the
      // internal cache is based on a vector; otherwise it uses a map).
      GMSH_API void getNode(const int nodeTag,
                            std::vector<double> & coord,
                            std::vector<double> & parametricCoord);

      // Gets the type and node tags of the mesh element with tag `tag'. This is a
      // useful but inefficient way of accessing mesh element data, as it relies on
      // a cache stored in the model. For large meshes all the elements in the
      // model should be numbered in a continuous sequence of tags from 1 to N to
      // maintain reasonnable performance (in this case the internal cache is based
      // on a vector; otherwise it uses a map).
      GMSH_API void getElement(const int elementTag,
                               int & type,
                               std::vector<int> & nodeTags);

      // Sets a mesh size constraint on the geometrical entities `dimTags'.
      // Currently only entities of dimension 0 (points) are handled.
      GMSH_API void setSize(const gmsh::vector_pair & dimTags,
                            const double size);

      // Sets a transfinite meshing constraint on the curve `tag', with `numNodes'
      // mesh nodes distributed according to `type' and `coef'. Currently supported
      // types are "Progression" (geometrical progression with power `coef') and
      // "Bump" (refinement toward both extremities of the curve).
      GMSH_API void setTransfiniteCurve(const int tag,
                                        const int numNodes,
                                        const std::string & type = "Progression",
                                        const double coef = 1.);

      // Sets a transfinite meshing constraint on the surface `tag'. `arrangement'
      // describes the arrangement of the triangles when the surface is not flagged
      // as recombined: currently supported values are "Left", "Right",
      // "AlternateLeft" and "AlternateRight". `cornerTags' can be used to specify
      // the (3 or 4) corners of the transfinite interpolation explicitly;
      // specifying the corners explicitly is mandatory if the surface has more
      // that 3 or 4 points on its boundary.
      GMSH_API void setTransfiniteSurface(const int tag,
                                          const std::string & arrangement = "Left",
                                          const std::vector<int> & cornerTags = std::vector<int>());

      // Sets a transfinite meshing constraint on the surface `tag'. `cornerTags'
      // can be used to specify the (6 or 8) corners of the transfinite
      // interpolation explicitly.
      GMSH_API void setTransfiniteVolume(const int tag,
                                         const std::vector<int> & cornerTags = std::vector<int>());

      // Sets a recombination meshing constraint on the geometrical entity of
      // dimension `dim' and tag `tag'. Currently only entities of dimension 2 (to
      // recombine triangles into quadrangles) are supported.
      GMSH_API void setRecombine(const int dim,
                                 const int tag);

      // Sets a smoothing meshing constraint on the geometrical entity of dimension
      // `dim' and tag `tag'. `val' iterations of a Laplace smoother are applied.
      GMSH_API void setSmoothing(const int dim,
                                 const int tag,
                                 const int val);

      // Sets a reverse meshing constraint on the geometrical entity of dimension
      // `dim' and tag `tag'. If `val' is true, the mesh orientation will be
      // reversed with respect to the natural mesh orientation (i.e. the
      // orientation consistent with the orientation of the geometrical entity). If
      // `val' is false, the mesh is left as-is.
      GMSH_API void setReverse(const int dim,
                               const int tag,
                               const bool val = true);

      // Embeds the geometrical entities of dimension `dim' and tags `tags' in the
      // (inDim, inTag) geometrical entity. `inDim' must be strictly greater than
      // `dim'.
      GMSH_API void embed(const int dim,
                          const std::vector<int> & tags,
                          const int inDim,
                          const int inTag);

      // Sets the meshes of the entities of dimension `dim' and tag `tags' as
      // periodic copies of the meshes of entities `tagsSource', using the affine
      // transformation specified in `affineTransformation' (16 entries of a 4x4
      // matrix, by row). Currently only available for `dim' == 1 and `dim' == 2.
      GMSH_API void setPeriodic(const int dim,
                                const std::vector<int> & tags,
                                const std::vector<int> & tagsSource,
                                const std::vector<double> & affineTransformation);

      namespace field { // Per-model mesh size field functions

        // Adds a new mesh size field of type `type'. If `tag' is positive, assigns
        // the tag explcitly; otherwise a new tag is assigned automatically.
        // Returns the field tag.
        GMSH_API int add(const std::string & type,
                         const int tag = -1);

        // Removes the field with tag `tag'.
        GMSH_API void remove(const int tag);

        // Sets the numerical option `option' to value `value' for field `tag'.
        GMSH_API void setNumber(const int tag,
                                const std::string & option,
                                const double value);

        // Sets the string option `option' to value `value' for field `tag'.
        GMSH_API void setString(const int tag,
                                const std::string & option,
                                const std::string & value);

        // Sets the numerical list option `option' to value `value' for field
        // `tag'.
        GMSH_API void setNumbers(const int tag,
                                 const std::string & option,
                                 const std::vector<double> & value);

        // Sets the field `tag' as the background mesh size field.
        GMSH_API void setAsBackgroundMesh(const int tag);

        // Sets the field `tag' as a boundary layer size field.
        GMSH_API void setAsBoundaryLayer(const int tag);

      } // namespace field

    } // namespace mesh

    namespace geo { // Internal per-model GEO CAD kernel functions

      // Adds a geometrical point in the internal GEO CAD representation, at
      // coordinates (x, y, z). If `meshSize' is > 0, adds a meshing constraint at
      // that point. If `tag' is positive, sets the tag explicitly; otherwise a new
      // tag is selected automatically. Returns the tag of the point. (Note that
      // the point will be added in the current model only after `synchronize' is
      // called. This behavior holds for all the entities added in the geo module.)
      GMSH_API int addPoint(const double x,
                            const double y,
                            const double z,
                            const double meshSize = 0.,
                            const int tag = -1);

      // Adds a straight line segment between the two points with tags `startTag'
      // and `endTag'. If `tag' is positive, sets the tag explicitly; otherwise a
      // new tag is selected automatically. Returns the tag of the line.
      GMSH_API int addLine(const int startTag,
                           const int endTag,
                           const int tag = -1);

      // Adds a circle arc (stricly smaller than Pi) between the two points with
      // tags `startTag' and `endTag', with center `centertag'. If `tag' is
      // positive, sets the tag explicitly; otherwise a new tag is selected
      // automatically. If (`nx', `ny', `nz') != (0,0,0), explicitely sets the
      // plane of the circle arc. Returns the tag of the circle arc.
      GMSH_API int addCircleArc(const int startTag,
                                const int centerTag,
                                const int endTag,
                                const int tag = -1,
                                const double nx = 0.,
                                const double ny = 0.,
                                const double nz = 0.);

      // Adds an ellipse arc (stricly smaller than Pi) between the two points
      // `startTag' and `endTag', with center `centertag' and major axis point
      // `majorTag'. If `tag' is positive, sets the tag explicitly; otherwise a new
      // tag is selected automatically. If (`nx', `ny', `nz') != (0,0,0),
      // explicitely sets the plane of the circle arc. Returns the tag of the
      // ellipse arc.
      GMSH_API int addEllipseArc(const int startTag,
                                 const int centerTag,
                                 const int majorTag,
                                 const int endTag,
                                 const int tag = -1,
                                 const double nx = 0.,
                                 const double ny = 0.,
                                 const double nz = 0.);

      // Adds a spline (Catmull-Rom) curve going through the points `pointTags'. If
      // `tag' is positive, sets the tag explicitly; otherwise a new tag is
      // selected automatically. Creates a periodic curve if the first and last
      // points are the same. Returns the tag of the spline curve.
      GMSH_API int addSpline(const std::vector<int> & pointTags,
                             const int tag = -1);

      // Adds a cubic b-spline curve with `pointTags' control points. If `tag' is
      // positive, sets the tag explicitly; otherwise a new tag is selected
      // automatically. Creates a periodic curve if the first and last points are
      // the same. Returns the tag of the b-spline curve.
      GMSH_API int addBSpline(const std::vector<int> & pointTags,
                              const int tag = -1);

      // Adds a Bezier curve with `pointTags' control points. If `tag' is positive,
      // sets the tag explicitly; otherwise a new tag is selected automatically.
      // Returns the tag of the Bezier curve.
      GMSH_API int addBezier(const std::vector<int> & pointTags,
                             const int tag = -1);

      // Adds a curve loop (a closed wire) formed by the curves `curveTags'.
      // `curveTags' should contain (signed) tags of geometrical enties of
      // dimension 1 forming a closed loop: a negative tag signifies that the
      // underlying curve is considered with reversed orientation. If `tag' is
      // positive, sets the tag explicitly; otherwise a new tag is selected
      // automatically. Returns the tag of the curve loop.
      GMSH_API int addCurveLoop(const std::vector<int> & curveTags,
                                const int tag = -1);

      // Adds a plane surface defined by one or more curve loops `wireTags'. The
      // first curve loop defines the exterior contour; additional curve loop
      // define holes. If `tag' is positive, sets the tag explicitly; otherwise a
      // new tag is selected automatically. Returns the tag of the surface.
      GMSH_API int addPlaneSurface(const std::vector<int> & wireTags,
                                   const int tag = -1);

      // Adds a surface filling the curve loops in `wireTags'. Currently only a
      // single curve loop is supported; this curve loop should be composed by 3 or
      // 4 curves only. If `tag' is positive, sets the tag explicitly; otherwise a
      // new tag is selected automatically. Returns the tag of the surface.
      GMSH_API int addSurfaceFilling(const std::vector<int> & wireTags,
                                     const int tag = -1,
                                     const int sphereCenterTag = -1);

      // Adds a surface loop (a closed shell) formed by `surfaceTags'.  If `tag' is
      // positive, sets the tag explicitly; otherwise a new tag is selected
      // automatically. Returns the tag of the shell.
      GMSH_API int addSurfaceLoop(const std::vector<int> & surfaceTags,
                                  const int tag = -1);

      // Adds a volume (a region) defined by one or more shells `shellTags'. The
      // first surface loop defines the exterior boundary; additional surface loop
      // define holes. If `tag' is positive, sets the tag explicitly; otherwise a
      // new tag is selected automatically. Returns the tag of the volume.
      GMSH_API int addVolume(const std::vector<int> & shellTags,
                             const int tag = -1);

      // Extrudes the geometrical entities `dimTags' by translation along (`dx',
      // `dy', `dz'). Returns extruded entities in `outDimTags'. If `numElements'
      // is not empty, also extrude the mesh: the entries in `numElements' give the
      // number of elements in each layer. If `height' is not empty, it provides
      // the (cummulative) height of the different layers, normalized to 1.
      GMSH_API void extrude(const gmsh::vector_pair & dimTags,
                            const double dx,
                            const double dy,
                            const double dz,
                            gmsh::vector_pair & outDimTags,
                            const std::vector<int> & numElements = std::vector<int>(),
                            const std::vector<double> & heights = std::vector<double>(),
                            const bool recombine = false);

      // Extrudes the geometrical entities `dimTags' by rotation of `angle' radians
      // around the axis of revolution defined by the point (`x', `y', `z') and the
      // direction (`ax', `ay', `az'). Returns extruded entities in `outDimTags'.
      // If `numElements' is not empty, also extrude the mesh: the entries in
      // `numElements' give the number of elements in each layer. If `height' is
      // not empty, it provides the (cummulative) height of the different layers,
      // normalized to 1.
      GMSH_API void revolve(const gmsh::vector_pair & dimTags,
                            const double x,
                            const double y,
                            const double z,
                            const double ax,
                            const double ay,
                            const double az,
                            const double angle,
                            gmsh::vector_pair & outDimTags,
                            const std::vector<int> & numElements = std::vector<int>(),
                            const std::vector<double> & heights = std::vector<double>(),
                            const bool recombine = false);

      // Extrudes the geometrical entities `dimTags' by a combined translation and
      // rotation of `angle' radians, along (`dx', `dy', `dz') and around the axis
      // of revolution defined by the point (`x', `y', `z') and the direction
      // (`ax', `ay', `az'). Returns extruded entities in `outDimTags'. If
      // `numElements' is not empty, also extrude the mesh: the entries in
      // `numElements' give the number of elements in each layer. If `height' is
      // not empty, it provides the (cummulative) height of the different layers,
      // normalized to 1.
      GMSH_API void twist(const gmsh::vector_pair & dimTags,
                          const double x,
                          const double y,
                          const double z,
                          const double dx,
                          const double dy,
                          const double dz,
                          const double ax,
                          const double ay,
                          const double az,
                          const double angle,
                          gmsh::vector_pair & outDimTags,
                          const std::vector<int> & numElements = std::vector<int>(),
                          const std::vector<double> & heights = std::vector<double>(),
                          const bool recombine = false);

      // Translates the geometrical entities `dimTags' along (`dx', `dy', `dz').
      GMSH_API void translate(const gmsh::vector_pair & dimTags,
                              const double dx,
                              const double dy,
                              const double dz);

      // Rotates the geometrical entities `dimTags' of `angle' radians around the
      // axis of revolution defined by the point (`x', `y', `z') and the direction
      // (`ax', `ay', `az').
      GMSH_API void rotate(const gmsh::vector_pair & dimTags,
                           const double x,
                           const double y,
                           const double z,
                           const double ax,
                           const double ay,
                           const double az,
                           const double angle);

      // Scales the geometrical entities `dimTag' by factors `a', `b' and `c' along
      // the three coordinate axes; use (`x', `y', `z') as the center of the
      // homothetic transformation.
      GMSH_API void dilate(const gmsh::vector_pair & dimTags,
                           const double x,
                           const double y,
                           const double z,
                           const double a,
                           const double b,
                           const double c);

      // Applies a symmetry transformation to the geometrical entities `dimTag',
      // with respect to the plane of equation `a' * x + `b' * y + `c' * z + `d' =
      // 0.
      GMSH_API void symmetry(const gmsh::vector_pair & dimTags,
                             const double a,
                             const double b,
                             const double c,
                             const double d);

      // Copies the entities `dimTags'; the new entities are returned in
      // `outDimTags'.
      GMSH_API void copy(const gmsh::vector_pair & dimTags,
                         gmsh::vector_pair & outDimTags);

      // Removes the entities `dimTags'. If `recursive' is true, removes all the
      // entities on their boundaries, down to dimension 0.
      GMSH_API void remove(const gmsh::vector_pair & dimTags,
                           const bool recursive = false);

      // Removes all duplicate entities (different entities at the same geometrical
      // location).
      GMSH_API void removeAllDuplicates();

      // Synchronize the internal GEO CAD representation with the current Gmsh
      // model. This can be called at any time, but since it involves a non trivial
      // amount of processing, the number of synchronization points should normally
      // be minimized.
      GMSH_API void synchronize();

      namespace mesh { // geo-specific meshing constraints

        // Sets a mesh size constraint on the geometrical entities `dimTags'.
        // Currently only entities of dimension 0 (points) are handled.
        GMSH_API void setSize(const gmsh::vector_pair & dimTags,
                              const double size);

        // Sets a transfinite meshing constraint on the curve `tag', with
        // `numNodes' mesh nodes distributed according to `type' and `coef'.
        // Currently supported types are "Progression" (geometrical progression
        // with power `coef') and "Bump" (refinement toward both extreminties of
        // the curve).
        GMSH_API void setTransfiniteCurve(const int tag,
                                          const int nPoints,
                                          const std::string & type = "Progression",
                                          const double coef = 1.);

        // Sets a transfinite meshing constraint on the surface `tag'.
        // `arrangement' describes the arrangement of the triangles when the
        // surface is not flagged as recombined: currently supported values are
        // "Left", "Right", "AlternateLeft" and "AlternateRight". `cornerTags' can
        // be used to specify the (3 or 4) corners of the transfinite interpolation
        // explicitly; specifying the corners explicitly is mandatory if the
        // surface has more that 3 or 4 points on its boundary.
        GMSH_API void setTransfiniteSurface(const int tag,
                                            const std::string & arrangement = "Left",
                                            const std::vector<int> & cornerTags = std::vector<int>());

        // Sets a transfinite meshing constraint on the surface `tag'. `cornerTags'
        // can be used to specify the (6 or 8) corners of the transfinite
        // interpolation explicitly.
        GMSH_API void setTransfiniteVolume(const int tag,
                                           const std::vector<int> & cornerTags = std::vector<int>());

        // Sets a recombination meshing constraint on the geometrical entity of
        // dimension `dim' and tag `tag'. Currently only entities of dimension 2
        // (to recombine triangles into quadrangles) are supported.
        GMSH_API void setRecombine(const int dim,
                                   const int tag,
                                   const double angle = 45.);

        // Sets a smoothing meshing constraint on the geometrical entity of
        // dimension `dim' and tag `tag'. `val' iterations of a Laplace smoother
        // are applied.
        GMSH_API void setSmoothing(const int dim,
                                   const int tag,
                                   const int val);

        // Sets a reverse meshing constraint on the geometrical entity of dimension
        // `dim' and tag `tag'. If `val' is true, the mesh orientation will be
        // reversed with respect to the natural mesh orientation (i.e. the
        // orientation consistent with the orientation of the geometrical entity).
        // If `val' is false, the mesh is left as-is.
        GMSH_API void setReverse(const int dim,
                                 const int tag,
                                 const bool val = true);

      } // namespace mesh

    } // namespace geo

    namespace occ { // Internal per-model OpenCASCADE CAD kernel functions

      // Adds a geometrical point in the internal OpenCASCADE CAD representation,
      // at coordinates (x, y, z). If `meshSize' is > 0, adds a meshing constraint
      // at that point. If `tag' is positive, sets the tag explicitly; otherwise a
      // new tag is selected automatically. Returns the tag of the point. (Note
      // that the point will be added in the current model only after `synchronize'
      // is called. This behavior holds for all the entities added in the occ
      // module.)
      GMSH_API int addPoint(const double x,
                            const double y,
                            const double z,
                            const double meshSize = 0.,
                            const int tag = -1);

      // Adds a straight line segment between the two points with tags `startTag'
      // and `endTag'. If `tag' is positive, sets the tag explicitly; otherwise a
      // new tag is selected automatically. Returns the tag of the line.
      GMSH_API int addLine(const int startTag,
                           const int endTag,
                           const int tag = -1);

      // Adds a circle arc between the two points with tags `startTag' and
      // `endTag', with center `centerTag'. If `tag' is positive, sets the tag
      // explicitly; otherwise a new tag is selected automatically. Returns the tag
      // of the circle arc.
      GMSH_API int addCircleArc(const int startTag,
                                const int centerTag,
                                const int endTag,
                                const int tag = -1);

      // Adds a circle of center (`x', `y', `z') and radius `r'. If `tag' is
      // positive, sets the tag explicitly; otherwise a new tag is selected
      // automatically. If `angle1' and `angle2' are specified, creates a circle
      // arc between the two angles. Returns the tag of the circle.
      GMSH_API int addCircle(const double x,
                             const double y,
                             const double z,
                             const double r,
                             const int tag = -1,
                             const double angle1 = 0.,
                             const double angle2 = 2*M_PI);

      // Adds an ellipse arc between the two points with tags `startTag' and
      // `endTag', with center `centerTag'. If `tag' is positive, sets the tag
      // explicitly; otherwise a new tag is selected automatically. Returns the tag
      // of the ellipse arc.
      GMSH_API int addEllipseArc(const int startTag,
                                 const int centerTag,
                                 const int endTag,
                                 const int tag = -1);

      // Adds an ellipse of center (`x', `y', `z') and radii `r1' and `r2' along
      // the x- and y-axes respectively. If `tag' is positive, sets the tag
      // explicitly; otherwise a new tag is selected automatically. If `angle1' and
      // `angle2' are specified, creates an ellipse arc between the two angles.
      // Returns the tag of the ellipse.
      GMSH_API int addEllipse(const double x,
                              const double y,
                              const double z,
                              const double r1,
                              const double r2,
                              const int tag = -1,
                              const double angle1 = 0.,
                              const double angle2 = 2*M_PI);

      // Adds a spline (C2 b-spline) curve going through the points `pointTags'. If
      // `tag' is positive, sets the tag explicitly; otherwise a new tag is
      // selected automatically. Creates a periodic curve if the first and last
      // points are the same. Returns the tag of the spline curve.
      GMSH_API int addSpline(const std::vector<int> & pointTags,
                             const int tag = -1);

      // Adds a b-spline curve of degree `degree' with `pointTags' control points.
      // If `weights', `knots' or `multiplicities' are not provided, default
      // parameters are computed automatically. If `tag' is positive, sets the tag
      // explicitly; otherwise a new tag is selected automatically. Creates a
      // periodic curve if the first and last points are the same. Returns the tag
      // of the b-spline curve.
      GMSH_API int addBSpline(const std::vector<int> & pointTags,
                              const int tag = -1,
                              const int degree = 3,
                              const std::vector<double> & weights = std::vector<double>(),
                              const std::vector<double> & knots = std::vector<double>(),
                              const std::vector<int> & multiplicities = std::vector<int>());

      // Adds a Bezier curve with `pointTags' control points. If `tag' is positive,
      // sets the tag explicitly; otherwise a new tag is selected automatically.
      // Returns the tag of the Bezier curve.
      GMSH_API int addBezier(const std::vector<int> & pointTags,
                             const int tag = -1);

      // Adds a wire (open or closed) formed by the curves `curveTags'. `curveTags'
      // should contain (signed) tags: a negative tag signifies that the underlying
      // curve is considered with reversed orientation. If `tag' is positive, sets
      // the tag explicitly; otherwise a new tag is selected automatically. Returns
      // the tag of the wire.
      GMSH_API int addWire(const std::vector<int> & curveTags,
                           const int tag = -1,
                           const bool checkClosed = false);

      // Adds a curve loop (a closed wire) formed by the curves `curveTags'.
      // `curveTags' should contain (signed) tags of curves forming a closed loop:
      // a negative tag signifies that the underlying curve is considered with
      // reversed orientation. If `tag' is positive, sets the tag explicitly;
      // otherwise a new tag is selected automatically. Returns the tag of the
      // curve loop.
      GMSH_API int addCurveLoop(const std::vector<int> & curveTags,
                                const int tag = -1);

      // Adds a rectangle with lower left corner at (`x', `y', `z') and upper right
      // corner at (`x' + `dx', `y' + `dy', `z'). If `tag' is positive, sets the
      // tag explicitly; otherwise a new tag is selected automatically. Rounds the
      // corners if `roundedRadius' is nonzero. Returns the tag of the rectangle.
      GMSH_API int addRectangle(const double x,
                                const double y,
                                const double z,
                                const double dx,
                                const double dy,
                                const int tag = -1,
                                const double roundedRadius = 0.);

      // Adds a disk with center (`xc', `yc', `zc') and radius `rx' along the
      // x-axis and `ry' along the y-axis. If `tag' is positive, sets the tag
      // explicitly; otherwise a new tag is selected automatically. Returns the tag
      // of the disk.
      GMSH_API int addDisk(const double xc,
                           const double yc,
                           const double zc,
                           const double rx,
                           const double ry,
                           const int tag = -1);

      // Adds a plane surface defined by one or more curve loops (or closed wires)
      // `wireTags'. The first curve loop defines the exterior contour; additional
      // curve loop define holes. If `tag' is positive, sets the tag explicitly;
      // otherwise a new tag is selected automatically. Returns the tag of the
      // surface.
      GMSH_API int addPlaneSurface(const std::vector<int> & wireTags,
                                   const int tag = -1);

      // Adds a surface filling the curve loops in `wireTags'. If `tag' is
      // positive, sets the tag explicitly; otherwise a new tag is selected
      // automatically. Returns the tag of the surface.
      GMSH_API int addSurfaceFilling(const int wireTag,
                                     const int tag = -1);

      // Adds a surface loop (a closed shell) formed by `surfaceTags'.  If `tag' is
      // positive, sets the tag explicitly; otherwise a new tag is selected
      // automatically. Returns the tag of the surface loop.
      GMSH_API int addSurfaceLoop(const std::vector<int> & surfaceTags,
                                  const int tag = -1);

      // Adds a volume (a region) defined by one or more surface loops `shellTags'.
      // The first surface loop defines the exterior boundary; additional surface
      // loop define holes. If `tag' is positive, sets the tag explicitly;
      // otherwise a new tag is selected automatically. Returns the tag of the
      // volume.
      GMSH_API int addVolume(const std::vector<int> & shellTags,
                             const int tag = -1);

      // Adds a sphere of center (`xc', `yc', `zc') and radius `r'. The optional
      // `angle1' and `angle2' arguments define the polar angle opening (from -Pi/2
      // to Pi/2). The optional `angle3' argument defines the azimuthal opening
      // (from 0 to 2*Pi). If `tag' is positive, sets the tag explicitly; otherwise
      // a new tag is selected automatically. Returns the tag of the sphere.
      GMSH_API int addSphere(const double xc,
                             const double yc,
                             const double zc,
                             const double radius,
                             const int tag = -1,
                             const double angle1 = -M_PI/2,
                             const double angle2 = M_PI/2,
                             const double angle3 = 2*M_PI);

      // Adds a parallelepipedic box defined by a point (`x', `y', `z') and the
      // extents along the x-, y- and z-axes. If `tag' is positive, sets the tag
      // explicitly; otherwise a new tag is selected automatically. Returns the tag
      // of the box.
      GMSH_API int addBox(const double x,
                          const double y,
                          const double z,
                          const double dx,
                          const double dy,
                          const double dz,
                          const int tag = -1);

      // Adds a cylinder, defined by the center (`x', `y', `z') of its first
      // circular face, the 3 components (`dx', `dy', `dz') of the vector defining
      // its axis and its radius `r'. The optional `angle' argument defines the
      // angular opening (from 0 to 2*Pi). If `tag' is positive, sets the tag
      // explicitly; otherwise a new tag is selected automatically. Returns the tag
      // of the cylinder.
      GMSH_API int addCylinder(const double x,
                               const double y,
                               const double z,
                               const double dx,
                               const double dy,
                               const double dz,
                               const double r,
                               const int tag = -1,
                               const double angle = 2*M_PI);

      // Adds a cone, defined by the center (`x', `y', `z') of its first circular
      // face, the 3 components of the vector (`dx', `dy', `dz') defining its axis
      // and the two radii `r1' and `r2' of the faces (these radii can be zero). If
      // `tag' is positive, sets the tag explicitly; otherwise a new tag is
      // selected automatically. `angle' defines the optional angular opening (from
      // 0 to 2*Pi). Returns the tag of the cone.
      GMSH_API int addCone(const double x,
                           const double y,
                           const double z,
                           const double dx,
                           const double dy,
                           const double dz,
                           const double r1,
                           const double r2,
                           const int tag = -1,
                           const double angle = 2*M_PI);

      // Adds a right angular wedge, defined by the right-angle point (`x', `y',
      // `z') and the 3 extends along the x-, y- and z-axes (`dx', `dy', `dz'). If
      // `tag' is positive, sets the tag explicitly; otherwise a new tag is
      // selected automatically. The optional argument `ltx' defines the top extent
      // along the x-axis. Returns the tag of the wedge.
      GMSH_API int addWedge(const double x,
                            const double y,
                            const double z,
                            const double dx,
                            const double dy,
                            const double dz,
                            const int tag = -1,
                            const double ltx = 0.);

      // Adds a torus, defined by its center (`x', `y', `z') and its 2 radii `r'
      // and `r2'. If `tag' is positive, sets the tag explicitly; otherwise a new
      // tag is selected automatically. The optional argument `angle' defines the
      // angular opening (from 0 to 2*Pi). Returns the tag of the wedge.
      GMSH_API int addTorus(const double x,
                            const double y,
                            const double z,
                            const double r1,
                            const double r2,
                            const int tag = -1,
                            const double angle = 2*M_PI);

      // Adds a volume (if the optional argument `makeSolid' is set) or surfaces
      // defined through the open or closed wires `wireTags'. If `tag' is positive,
      // sets the tag explicitly; otherwise a new tag is selected automatically.
      // The new entities are returned in `outDimTags'. If the optional argument
      // `makeRuled' is set, the surfaces created on the boundary are forced to be
      // ruled surfaces.
      GMSH_API void addThruSections(const std::vector<int> & wireTags,
                                    gmsh::vector_pair & outDimTags,
                                    const int tag = -1,
                                    const bool makeSolid = true,
                                    const bool makeRuled = false);

      // Adds a hollowed volume built from an initial volume `volumeTag' and a set
      // of faces from this volume `excludeSurfaceTags', which are to be removed.
      // The remaining faces of the volume become the walls of the hollowed solid,
      // with thickness `offset'. If `tag' is positive, sets the tag explicitly;
      // otherwise a new tag is selected automatically.
      GMSH_API void addThickSolid(const int volumeTag,
                                  const std::vector<int> & excludeSurfaceTags,
                                  const double offset,
                                  gmsh::vector_pair & outDimTags,
                                  const int tag = -1);

      // Extrudes the geometrical entities `dimTags' by translation along (`dx',
      // `dy', `dz'). Returns extruded entities in `outDimTags'. If `numElements'
      // is not empty, also extrude the mesh: the entries in `numElements' give the
      // number of elements in each layer. If `height' is not empty, it provides
      // the (cummulative) height of the different layers, normalized to 1.
      GMSH_API void extrude(const gmsh::vector_pair & dimTags,
                            const double dx,
                            const double dy,
                            const double dz,
                            gmsh::vector_pair & outDimTags,
                            const std::vector<int> & numElements = std::vector<int>(),
                            const std::vector<double> & heights = std::vector<double>(),
                            const bool recombine = false);

      // Extrudes the geometrical entities `dimTags' by rotation of `angle' radians
      // around the axis of revolution defined by the point (`x', `y', `z') and the
      // direction (`ax', `ay', `az'). Returns extruded entities in `outDimTags'.
      // If `numElements' is not empty, also extrude the mesh: the entries in
      // `numElements' give the number of elements in each layer. If `height' is
      // not empty, it provides the (cummulative) height of the different layers,
      // normalized to 1.
      GMSH_API void revolve(const gmsh::vector_pair & dimTags,
                            const double x,
                            const double y,
                            const double z,
                            const double ax,
                            const double ay,
                            const double az,
                            const double angle,
                            gmsh::vector_pair & outDimTags,
                            const std::vector<int> & numElements = std::vector<int>(),
                            const std::vector<double> & heights = std::vector<double>(),
                            const bool recombine = false);

      // Adds a pipe by extruding the entities `dimTags' along the wire `wireTag'.
      // Returns the pipe in `outDimTags'.
      GMSH_API void addPipe(const gmsh::vector_pair & dimTags,
                            const int wireTag,
                            gmsh::vector_pair & outDimTags);

      // Fillets the volumes `volumeTags' on the curves `curveTags' with radius
      // `radius'. Returns the filleted entities in `outDimTags'. Removes the
      // original volume if `removeVolume' is set.
      GMSH_API void fillet(const std::vector<int> & volumeTags,
                           const std::vector<int> & curveTags,
                           const double radius,
                           gmsh::vector_pair & outDimTags,
                           const bool removeVolume = true);

      // Computes the boolean union (the fusion) of the entities `objectDimTags'
      // and `toolDimTags'. Returns the resulting entities in `outDimTags'. If
      // `tag' is positive, attemps to set the tag explicitly (ony valid if the
      // boolean operation results in a single entity). Removes the object if
      // `removeObject' is set. Removes the tool if `removeTool' is set.
      GMSH_API void fuse(const gmsh::vector_pair & objectDimTags,
                         const gmsh::vector_pair & toolDimTags,
                         gmsh::vector_pair & outDimTags,
                         std::vector<gmsh::vector_pair> & outDimTagsMap,
                         const int tag = -1,
                         const bool removeObject = true,
                         const bool removeTool = true);

      // Computes the boolean intersection (the common parts) of the entities
      // `objectDimTags' and `toolDimTags'. Returns the resulting entities in
      // `outDimTags'. If `tag' is positive, attemps to set the tag explicitly (ony
      // valid if the boolean operation results in a single entity). Removes the
      // object if `removeObject' is set. Removes the tool if `removeTool' is set.
      GMSH_API void intersect(const gmsh::vector_pair & objectDimTags,
                              const gmsh::vector_pair & toolDimTags,
                              gmsh::vector_pair & outDimTags,
                              std::vector<gmsh::vector_pair> & outDimTagsMap,
                              const int tag = -1,
                              const bool removeObject = true,
                              const bool removeTool = true);

      // Computes the boolean difference between the entities `objectDimTags' and
      // `toolDimTags'. Returns the resulting entities in `outDimTags'. If `tag' is
      // positive, attemps to set the tag explicitly (ony valid if the boolean
      // operation results in a single entity). Removes the object if
      // `removeObject' is set. Removes the tool if `removeTool' is set.
      GMSH_API void cut(const gmsh::vector_pair & objectDimTags,
                        const gmsh::vector_pair & toolDimTags,
                        gmsh::vector_pair & outDimTags,
                        std::vector<gmsh::vector_pair> & outDimTagsMap,
                        const int tag = -1,
                        const bool removeObject = true,
                        const bool removeTool = true);

      // Copmutes the boolean fragments (general fuse) of the entities
      // `objectDimTags' and `toolDimTags'. Returns the resulting entities in
      // `outDimTags'. If `tag' is positive, attemps to set the tag explicitly (ony
      // valid if the boolean operation results in a single entity). Removes the
      // object if `removeObject' is set. Removes the tool if `removeTool' is set.
      GMSH_API void fragment(const gmsh::vector_pair & objectDimTags,
                             const gmsh::vector_pair & toolDimTags,
                             gmsh::vector_pair & outDimTags,
                             std::vector<gmsh::vector_pair> & outDimTagsMap,
                             const int tag = -1,
                             const bool removeObject = true,
                             const bool removeTool = true);

      // Translates the geometrical entities `dimTags' along (`dx', `dy', `dz').
      GMSH_API void translate(const gmsh::vector_pair & dimTags,
                              const double dx,
                              const double dy,
                              const double dz);

      // Rotates the geometrical entities `dimTags' of `angle' radians around the
      // axis of revolution defined by the point (`x', `y', `z') and the direction
      // (`ax', `ay', `az').
      GMSH_API void rotate(const gmsh::vector_pair & dimTags,
                           const double x,
                           const double y,
                           const double z,
                           const double ax,
                           const double ay,
                           const double az,
                           const double angle);

      // Scales the geometrical entities `dimTag' by factors `a', `b' and `c' along
      // the three coordinate axes; use (`x', `y', `z') as the center of the
      // homothetic transformation.
      GMSH_API void dilate(const gmsh::vector_pair & dimTags,
                           const double x,
                           const double y,
                           const double z,
                           const double a,
                           const double b,
                           const double c);

      // Applies a symmetry transformation to the geometrical entities `dimTag',
      // with respect to the plane of equation `a' * x + `b' * y + `c' * z + `d' =
      // 0.
      GMSH_API void symmetry(const gmsh::vector_pair & dimTags,
                             const double a,
                             const double b,
                             const double c,
                             const double d);

      // Copies the entities `dimTags'; the new entities are returned in
      // `outDimTags'.
      GMSH_API void copy(const gmsh::vector_pair & dimTags,
                         gmsh::vector_pair & outDimTags);

      // Removes the entities `dimTags'. If `recursive' is true, removes all the
      // entities on their boundaries, down to dimension 0.
      GMSH_API void remove(const gmsh::vector_pair & dimTags,
                           const bool recursive = false);

      // Removes all duplicate entities (different entities at the same geometrical
      // location) after intersecting (using boolean fragments) all highest
      // dimensional entities.
      GMSH_API void removeAllDuplicates();

      // Imports BREP, STEP or IGES shapes from the file `fileName'. The imported
      // entities are returned in `outDimTags'. If the optional argument
      // `highestDimOnly' is set, only import the highest dimensional entities in
      // the file. The optional argument `format' can be used to force the format
      // of the file (currently "brep", "step" or "iges").
      GMSH_API void importShapes(const std::string & fileName,
                                 gmsh::vector_pair & outDimTags,
                                 const bool highestDimOnly = true,
                                 const std::string & format = "");

      // Sets a mesh size constraint on the geometrical entities `dimTags'.
      // Currently only entities of dimension 0 (points) are handled.
      GMSH_API void setMeshSize(const gmsh::vector_pair & dimTags,
                                const double size);

      // Synchronize the internal OpenCASCADE CAD representation with the current
      // Gmsh model. This can be called at any time, but since it involves a non
      // trivial amount of processing, the number of synchronization points should
      // normally be minimized.
      GMSH_API void synchronize();

    } // namespace occ

  } // namespace model

  namespace view { // Post-processing view functions

    // Adds a new post-processing view, with name `name'. If `tag' is positive use
    // it (and remove the view with that tag if it already exists), otherwise
    // associate a new tag. Returns the view tag.
    GMSH_API int add(const std::string & name,
                     const int tag = -1);

    // Removes the view with tag `tag'.
    GMSH_API void remove(const int tag);

    // Gets the index of the view with tag `tag' in the list of currently loaded
    // views. This dynamic index (it can change when views are removed) is used to
    // access view options.
    GMSH_API int getIndex(const int tag);

    // Gets the tags of all views.
    GMSH_API void getTags(std::vector<int> & tags);

    // Adds model-based post-processing data to the view with tag `tag'.
    // `modelName' identifies the model the data is attached to. `dataType'
    // specifies the type of data, currently either "NodeData", "ElementData" or
    // "ElementNodeData". `step' specifies the identifier (>= 0) of the data in a
    // sequence. `tags' gives the tags of the nodes or elements in the mesh to
    // which the data is associated. `data' is a vector of the same length as
    // `tags': each entry is the vector of double precision numbers representing
    // the data associated with the corresponding tag. The optional `time' argument
    // associate a time value with the data. `numComponents' gives the number of
    // data components (1 for scalar data, 3 for vector data, etc.) per entity; if
    // negative, it is automatically inferred (when possible) from the input data.
    // `partition' allows to specify data in several sub-sets.
    GMSH_API void addModelData(const int tag,
                               const int step,
                               const std::string & modelName,
                               const std::string & dataType,
                               const std::vector<int> & tags,
                               const std::vector<std::vector<double> > & data,
                               const double time = 0.,
                               const int numComponents = -1,
                               const int partition = 0);

    // Gets model-based post-processing data from the view with tag `tag' at step
    // `step'. Returns the `data' associated to the nodes or the elements with tags
    // `tags', as well as the `dataType' and the number of components
    // `numComponents'.
    GMSH_API void getModelData(const int tag,
                               const int step,
                               std::string & dataType,
                               std::vector<int> & tags,
                               std::vector<std::vector<double> > & data,
                               double & time,
                               int & numComponents);

    // Adds list-based post-processing data to the view with tag `tag'. `type'
    // identifies the data: "SP" for scalar points, "VP", for vector points, etc.
    // `numEle' gives the number of elements in the data. `data' contains the data
    // for the `numEle' elements.
    GMSH_API void addListData(const int tag,
                              const std::string & type,
                              const int numEle,
                              const std::vector<double> & data);

    // Gets list-based post-processing data from the view with tag `tag'. Returns
    // the types `dataTypes', the number of elements `numElements' for each data
    // type and the `data' for each data type.
    GMSH_API void getListData(const int tag,
                              std::vector<std::string> & dataType,
                              std::vector<int> & numElements,
                              std::vector<std::vector<double> > & data);

    // Probes the view `tag' for its `value' at point (`x', `y', `z'). Returns only
    // the value at step `step' is `step' is positive. Returns only values with
    // `numComp' if `numComp' is positive. Returns the gradient of the `value' if
    // `gradient' is set. Probes with a geometrical tolerance (in the reference
    // unit cube) of `tolerance' if `tolerance' is not zero. Returns the result
    // from the element described by its coordinates if `xElementCoord',
    // `yElementCoord' and `zElementCoord' are provided.
    GMSH_API void probe(const int tag,
                        const double x,
                        const double y,
                        const double z,
                        std::vector<double> & value,
                        const int step = -1,
                        const int numComp = -1,
                        const bool gradient = false,
                        const double tolerance = 0.,
                        const std::vector<double> & xElemCoord = std::vector<double>(),
                        const std::vector<double> & yElemCoord = std::vector<double>(),
                        const std::vector<double> & zElemCoord = std::vector<double>());

    // Writes the view to a file `fileName'. The export format is determined by the
    // file extension. Appends to the file if `append' is set.
    GMSH_API void write(const int tag,
                        const std::string & fileName,
                        const bool append = false);

  } // namespace view

  namespace plugin { // Plugin functions

    // Sets the numerical option `option' to the value `value' for plugin `name'.
    GMSH_API void setNumber(const std::string & name,
                            const std::string & option,
                            const double value);

    // Sets the string option `option' to the value `value' for plugin `name'.
    GMSH_API void setString(const std::string & name,
                            const std::string & option,
                            const std::string & value);

    // Runs the plugin `name'.
    GMSH_API void run(const std::string & name);

  } // namespace plugin

  namespace graphics { // Graphics functions

    // Draws all the OpenGL scenes.
    GMSH_API void draw();

  } // namespace graphics

  namespace fltk { // Fltk graphical user interface functions

    // Creates the Fltk graphical user interface.
    GMSH_API void initialize();

    // Waits at most `time' seconds for user interface events and returns. If
    // `time' < 0, waits indefinitely. First automatically creates the user
    // interface if it has not yet been initialized.
    GMSH_API void wait(const double time = -1.);

    // Runs the event loop of the Fltk graphical user interface, i.e. repeatedly
    // calls `wait'. First automatically creates the user interface if it has not
    // yet been initialized.
    GMSH_API void run();

  } // namespace fltk

  namespace onelab { // ONELAB server functions

    // Gets `data' from the ONELAB server.
    GMSH_API void get(std::string & data,
                      const std::string & format = "json");

    // Sets `data' in the ONELAB server.
    GMSH_API void set(const std::string & data,
                      const std::string & format = "json");

    // Runs a ONELAB client. If `name' is provided, creates a new ONELAB client
    // with name `name' and executes `command'. If not, attemps to run a client
    // that might be linked to the processed input files.
    GMSH_API void run(const std::string & name = "",
                      const std::string & command = "");

  } // namespace onelab

} // namespace gmsh

#endif
