;; This buffer is for text that is not saved, and for Lisp evaluation.
;; To create a file, visit it with C-x C-f and enter text in its buffer.

*

double**  HierarchicalBasisH1Quad::generateGradiendBasis( double const& u, double const& v){
 

  double dlambda1=0.5;
  double dlambda2=-0.5;
  double dlambda3=0.5;
  double dlambda4=-0.5;
  double lambda1=affineCoordinate(1,u,v);
  double lambda2=affineCoordinate(2,u,v);
  double lambda3=affineCoordinate(3,u,v);
  double lambda4=affineCoordinate(4,u,v);
  int nTotalFunction=  this->nVertexFunction +  this->nEdgeFunction +  this->nFaceFunction + this->nBubbleFunction  ; //Total number of shape function
  double** GradiendHierarchicalBasis=new double*[nTotalFunction];
  for(int h=0;h<nTotalFunction;h++){
    GradientHierarchicalBasis[h]=new double[2];
  }
  std::vector<std::string> debug(nTotalFunction);
  //vertex shape functions:
  GradientHierarchicalBasis[0]=  lambda2*lambda4;
  GradientHierarchicalBasis[1]=  lambda1*lambda4;
  GradientHierarchicalBasis[2]=  lambda1*lambda3;
  GradientHierarchicalBasis[3]=  lambda2*lambda3;
  
  debug[0]="v1";
  debug[1]="v2";
  debug[2]="v3";
  debug[3]="v4";
  //edge 1 & 2 shape functions and a part of  bubble functions (all lk(v)) :
   int minpe1pe2=std::min(this->pOrderEdge[0],this->pOrderEdge[1]);
  for(int k=2;k<=minpe1pe2;k++){
    double lk=OrthogonalPoly::EvalLobatto(k,v);
    double  phie1=lambda2*lk;
    double phie2=lambda1*lk;
    HierarchicalBasis[k+2]=phie1;
    debug[k+2]="phie1 "+ std::to_string(k);
    HierarchicalBasis[k+1+this->pOrderEdge[0]]=phie2;
    debug[k+1+this->pOrderEdge[0]]="phie2 "+ std::to_string(k);
    int s=k-1;
    int iterator=1;
    while(iterator<=this->pb1-1){
      HierarchicalBasis[this->nEdgeFunction+s+3]= lk;
      debug[this->nEdgeFunction+s+3]="bullev "+ std::to_string(k);
	s=s+this->pb2-1;
	iterator++;
	}
  }
  if(this->pOrderEdge[0]>minpe1pe2){
    for( int k=minpe1pe2+1;k<=this->pOrderEdge[0];k++){
        double lk=OrthogonalPoly::EvalLobatto(k,v);
	double phie1=lambda2*lk;
	HierarchicalBasis[k+2]=phie1;
        debug[k+2]="phie1 "+ std::to_string(k);
	int s=k-1;
	int iterator=1;
        while(iterator<=this->pb1-1){
           HierarchicalBasis[this->nEdgeFunction+s+3]=lk;
	     debug[this->nEdgeFunction+s+3]="bullev "+ std::to_string(k);
         	s=s+this->pb2-1;
		iterator++;
	}
    }

  }
  else{
    for(int k=minpe1pe2+1;k<=this->pOrderEdge[1];k++){
        double lk=OrthogonalPoly::EvalLobatto(k,v);
	double phie2=lambda1*lk;
	debug[k+1+this->pOrderEdge[0]]="phie2 "+ std::to_string(k);
	HierarchicalBasis[k+1+this->pOrderEdge[0]]=phie2;
	int s=k-1;
	int iterator=1;
        while(iterator<=this->pb1-1){
           HierarchicalBasis[this->nEdgeFunction+s+3]= lk;
	   debug[this->nEdgeFunction+s+3]="bullev "+ std::to_string(k);
         	s=s+this->pb2-1;
		iterator++;
	}
    }
  }
  int maxpe1pe2= std::max(this->pOrderEdge[0],this->pOrderEdge[1]);
  for(int k=maxpe1pe2+1;k<=this->pb2;k++){
        double lk=OrthogonalPoly::EvalLobatto(k,v);
	int s=k-1;
	int iterator=1;
        while(iterator<=this->pb1-1){
           HierarchicalBasis[this->nEdgeFunction+s+3]= lk;
	    debug[this->nEdgeFunction+s+3]="bullev "+ std::to_string(k);
         	s=s+this->pb2-1;
		iterator++;
	}
    }
  
   //edge 3 & 4  shape functions and the second part  of  bubble functions (all lk(u)) :
  int minpe3pe4=std::min(this->pOrderEdge[2],this->pOrderEdge[3]);
  for(int k=2;k<=minpe3pe4;k++){
    double lk=OrthogonalPoly::EvalLobatto(k,u);
    double  phie3=lambda4*lk;
    double phie4=lambda3*lk;
    HierarchicalBasis[k+this->pOrderEdge[0]+ this->pOrderEdge[1]]=phie3;
    debug[k+this->pOrderEdge[0]+ this->pOrderEdge[1]]="phie3 "+ std::to_string(k);
    HierarchicalBasis[k+this->pOrderEdge[0]+ this->pOrderEdge[1]+this->pOrderEdge[2]-1]=phie4;
    debug[k+this->pOrderEdge[0]+ this->pOrderEdge[1]+this->pOrderEdge[2]-1]="phie4 "+ std::to_string(k);
    int iterator=1;
    while(iterator<this->pb2){
      int nbr=this->nEdgeFunction+(k-2)*(pb2-1)+3+iterator;
      HierarchicalBasis[nbr]= HierarchicalBasis[nbr]*lk;
    
      debug[nbr]=debug[nbr]+"u "+ std::to_string(k);

	iterator++;
    }
  }
  if(this->pOrderEdge[2]>minpe3pe4){
    for( int k=minpe3pe4+1;k<=this->pOrderEdge[2];k++){
      double lk=OrthogonalPoly::EvalLobatto(k,u);
	double phie3=lambda4*lk;
        HierarchicalBasis[k+this->pOrderEdge[0]+ this->pOrderEdge[1]]=phie3;
            debug[k+this->pOrderEdge[0]+ this->pOrderEdge[1]]="phie3 "+ std::to_string(k);
	int iterator=1;
        while(iterator<this->pb2){
	  int nbr=this->nEdgeFunction+(k-2)*(pb2-1)+3+iterator;
             HierarchicalBasis[nbr]= HierarchicalBasis[nbr]*lk;
	      debug[nbr]=debug[nbr]+"u "+ std::to_string(k);
         	iterator++;
	}
    }

  }
  else{
    for(int k=minpe3pe4+1;k<=this->pOrderEdge[3];k++){
      double lk=OrthogonalPoly::EvalLobatto(k,u);
      	double phie4=lambda3*lk;
        HierarchicalBasis[k+this->pOrderEdge[0]+ this->pOrderEdge[1]+this->pOrderEdge[2]-1]=phie4;
		 debug[k+this->pOrderEdge[0]+ this->pOrderEdge[1]+this->pOrderEdge[2]-1]="phie4 "+ std::to_string(k);
	 int iterator=1;
        while(iterator<this->pb2){
	  int nbr=this->nEdgeFunction+(k-2)*(pb2-1)+3+iterator;
	     HierarchicalBasis[nbr]= HierarchicalBasis[nbr]*lk;
	     
	      debug[nbr]=debug[nbr]+"u "+ std::to_string(k);;
	     iterator++;
	     }
    }
  }
   int maxpe3pe4= std::max(this->pOrderEdge[2],this->pOrderEdge[3]);
  for(int k=maxpe3pe4+1;k<=this->pb1;k++){
    double lk=OrthogonalPoly::EvalLobatto(k,u);
     
	int iterator=1;
        while(iterator<this->pb2){
	  int nbr=this->nEdgeFunction+(k-2)*(pb2-1)+3+iterator;
             HierarchicalBasis[nbr]= HierarchicalBasis[nbr]*lk;
	      debug[nbr]=debug[nbr]+"u "+ std::to_string(k);;
	     iterator++;
	}
    }

  //debug:
  for (int i =0; i<nTotalFunction;i++){
    std::cout<<debug[i]<<std::endl;
    std::cout<<HierarchicalBasis[i]<<std::endl;
  }
  return  HierarchicalBasis;





}
 
*/
